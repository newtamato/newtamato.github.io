<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[分类:unity | 番茄手册]]></title>
  <link href="http://www.newtomato.me/blog/categories/unity/atom.xml" rel="self"/>
  <link href="http://www.newtomato.me/"/>
  <updated>2018-02-11T00:32:04+08:00</updated>
  <id>http://www.newtomato.me/</id>
  <author>
    <name><![CDATA[newtomato]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Unity Shader基础函数：TRANSFORM_TEX]]></title>
    <link href="http://www.newtomato.me/blog/2018/02/11/unity-transform-tex"/>
    <updated>2018-02-11T00:30:09+08:00</updated>
    <id>http://www.newtomato.me/blog/2018/02/11/unity-transform-tex</id>
    <content type="html"><![CDATA[<p>我们知道在unity中tiling和offset是用来设置纹理的重复，也就是俗称的贴瓷砖。<br />
只要我们将tiling设置为（2，2）那么效果如下：<br />
<img src="http://7xuepc.com1.z0.glb.clouddn.com/2018-02-07-15180039093865.jpg" alt="=w300" /></p>

<p>此时，对这个GameObject添加shader，正确读取具体的uv坐标就要用到<code>TRANSFORM_TEX</code>函数。<br />
（如果纹理的tiling=1，offset=1的情况下，可以不使用这个函数）</p>

<pre><code>#define TRANSFORM_TEX(tex,name) (tex.xy * name##_ST.xy + name##_ST.zw)
</code></pre>

<p>语法问题，不是我们的重点。大家可以自行搜索。<br />
这个函数的意思就是对<strong>texture的uv坐标进行一个缩放操作和位移操作</strong>。<br />
那么<code>tex.xy</code>作为关键的参数，他的范围是多少，这个公式操作之后，生成的uv范围又是多少？</p>

<!--more-->

<p>在Shader中通过对顶点函数的修改：</p>

<pre><code>v2f vert(a2v v) {
	v2f o;
	o.pos = UnityObjectToClipPos(v.vertex);
	
	o.worldNormal = UnityObjectToWorldNormal(v.normal);
	
	o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;

	//o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);
	//无论外面的tiling和offset怎么修改，这里一直就是v.texcoord
	o.uv = v.texcoord;
	
	return o;
}
</code></pre>

<p>此时发现，外面的渲染并没有出问题。表现就是tiling(1,1),offset(0,0)的样子。因此可以得知，<code>v.texcoord</code>的u，v范围均是（0，1）<br />
那么通过公式可以推算，如果tiling是（2，2）,计算出来的uv的范围就是（0，2），如此超过了纹理的坐标范围，拿不到纹理才对，怎么实现的贴图？</p>

<p>如果你和我有同样的困惑，那么希望我的回答能让你茅塞顿开！</p>

<p>答案就是纹理设置了贴图方式，这种方式使用opengl的<code>glTexParameteri</code>函数进行设置。(只看opengl，D3D原理相似)</p>

<pre><code>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
</code></pre>

<p>如果纹理坐标超过（0，1）范围，则开始从头开始寻址。也就是说原先纹理坐标是(0，0.5),此时经过放大2倍，变成（0，1），那么重新开始读取纹理的（0，0）位置。<br />
至此重复贴出的效果就实现了。</p>

<p>另外在unity中纹理贴图方式是在如下位置设置的：<br />
<img src="http://7xuepc.com1.z0.glb.clouddn.com/2018-02-07-15180058478883.jpg" alt="=w300" /></p>

<p>如果你把Wrap Mode设置为<code>Clamp</code>，纹理寻址找不到直接就不显示了。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[怎么控制镜头跟随人物移动]]></title>
    <link href="http://www.newtomato.me/blog/2017/05/14/kong-zhi-jing-tou-gen-sui"/>
    <updated>2017-05-14T17:48:56+08:00</updated>
    <id>http://www.newtomato.me/blog/2017/05/14/kong-zhi-jing-tou-gen-sui</id>
    <content type="html"><![CDATA[<p>在第三人称射击游戏中，镜头是跟随英雄的移动而移动的。这是如何实现的呢？<br />
我们从简入手，开始说一下怎么控制镜头的移动。<br />
这算是很基础的unity入门了。但是我却没有给我朋友讲清楚。丢人哦！<br />
<img src="http://wx2.sinaimg.cn/mw690/805c3d47ly1fevq3bkj1mg206y06y4ql.gif" alt="" /></p>

<h2 id="section">开始入手</h2>

<p>镜头移动是需要控制镜头的位置随着英雄的位置变动而变动。<br />
因此有下面的代码：<br />
<!--more--><br />
<code>
public class SimpleFollower : MonoBehaviour {
	public Transform target;
	void Update () {
		transform.position = target.position;
	}
}
</code></p>

<p>target就是英雄，把这个组件拖到英雄身上。移动英雄。看看效果。<br />
是不是发现镜头嵌在了英雄身上，英雄的position的中心点在身体重心上，这是镜头也在这。因为出现嵌入感。所以应该增加一个偏移量offset。</p>

<p>一般我们在场景中先设置好镜头和英雄的偏移。在代码中可以计算得到。</p>

<pre><code>private Vector3 _deltaPosition；
void Start () {
	_deltaPosition = transform.position - target.position;
}
</code></pre>

<p>英雄在移动中需要将这个偏移量也一并计算在内。<br />
<code>
transform.position = target.position + _deltaPosition;
</code></p>

<p>此时运行unity，镜头跟随没问题了。但是还有个问题就是此时玩家如果左右移动，镜头就又出现问题了。我们需要镜头一直在人身后做跟随。即使人物左右移动，镜头也要左右移动才更好。<br />
因此代码还需要优化。就是增加旋转的考虑。</p>

<p>假设我们只考虑玩家左右渲染，即围绕Y轴的旋转。</p>

<pre><code>float yAngle = target.rotation.eulerAngles.y;
Quaternion quat = Quaternion.Euler (0, yAngle, 0);
transform.position = target.position + _deltaPosition * quat;
</code></pre>

<p>这样运行之后，镜头确实随着移动，但是表现不够自然。因此就需要用到Lerp函数。</p>

<pre><code>transform.position = Vector3.Lerp(transform.position,target.position + _deltaPosition * quat,Time.deltaTime);
</code></pre>

<p>同样的上面计算的旋转角度也可以使用Lerp函数。</p>

<pre><code>float yAngle = Mathf.Lerp (transform.rotation.eulerAngles.y,target.rotation.eulerAngles.y,Time.deltaTime * damping);
Quaternion quat = Quaternion.Euler (0, yAngle, 0);

transform.position = Vector3.Lerp(transform.position,target.position + _deltaPosition * quat,Time.deltaTime);

</code></pre>

<h2 id="section-1">可选阅读</h2>

<p>在FPS游戏中，有输入设备可控制英雄的移动，例如手柄，键盘等。我们这里使用鼠标控制英雄的旋转。</p>

<pre><code>_horizontalRotation += Mathf.Clamp(Input.GetAxis("Mouse X"), -1, 1)* rotateSpeed * Time.deltaTime;
_horizontalRotation = Mathf.Clamp (_horizontalRotation, -90, 90);
target.transform.rotation = Quaternion.Euler (0, _horizontalRotation, 0);
</code></pre>

<p>此处_horizontalRotation用于记录英雄的旋转角度。这里做了个限制，英雄旋转不能超过左转90度和右转90度。<br />
rotateSpeed是旋转速度。每秒钟旋转多少。<br />
通过Quaternion.Euler计算一个旋转四元数，用来控制英雄的旋转。</p>

<h2 id="section-2">结语</h2>
<p>上面旋转用到了矩阵和向量的乘法运算。将一个坐标转换到另一个坐标。其他的都是通过Lerp和Clamp对数据进行处理。</p>

<p>总体来说，为了达到那种顺畅的动作，需要增加其他Vector3的转换以及fieldOfView来增加动感。如有兴趣大家可以把Unity官方的镜头跟随代码打开看看。</p>

]]></content>
  </entry>
  
</feed>
