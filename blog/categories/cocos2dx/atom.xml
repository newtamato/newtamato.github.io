<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[分类:cocos2dx | 番茄手册]]></title>
  <link href="http://www.newtomato.me/blog/categories/cocos2dx/atom.xml" rel="self"/>
  <link href="http://www.newtomato.me/"/>
  <updated>2017-12-03T23:21:04+08:00</updated>
  <id>http://www.newtomato.me/</id>
  <author>
    <name><![CDATA[newtomato]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[为游戏增加记录回放功能]]></title>
    <link href="http://www.newtomato.me/blog/2017/10/08/hui-fang"/>
    <updated>2017-10-08T17:29:29+08:00</updated>
    <id>http://www.newtomato.me/blog/2017/10/08/hui-fang</id>
    <content type="html"><![CDATA[<p>为游戏增加回放功能的主要目的是可以将原来的操作重新播放一遍，很快的定位问题。尤其的不易复现的问题。<br />
早先定位不易复现的问题采用的方法是让服务器记录玩家的操作请求。<br />
如果发生问题，可以根据请求日志做分析。<br />
这种方案一般是用在游戏上线之后。在上线之前，只能靠开发和测试同学大量的测试。<br />
所以当我看到cocos2dx增加一个控制台（<code>Console</code>）类的时候，就突发奇想，是否可以在前端做一个简单的记录回放。<br />
<img src="http://7xuepc.com1.z0.glb.clouddn.com/2017-10-08-柴犬.jpg" alt="柴犬" /><br />
柴柴帮忙镇楼！<br />
<!--more--></p>

<h3 id="section">原理和问题</h3>

<p>记录回放不是游戏业务逻辑，不需要增加额外的代码。它独立于游戏存在。记录玩家的点击操作。保存到本地文件中。然后在游戏启动之后，读取文件内容，挨个播放玩家的点击。以此实现回放功能。</p>

<p>这里涉及到的问题是：</p>

<ol>
  <li>玩家上次操作的游戏和本次回放的游戏内容要一致。现在游戏为了增加趣味性，很多采用随机。比如道具物品的生成，如果不一致，回放肯定出问题。</li>
  <li>记录的点击位置是以当前设备分辨率为准。如果回放设备和当前设备分辨率不一致。位置信息不对，点击也会出问题。</li>
  <li>即使解决了上面两个问题，如果上次点击和这次点击之间用时10s钟（可能是网络卡住，可能是性能出现问题）。当回放的时候，挨个触发的点击之间时长小于10s中，那么点击就不能正确触发。依然会出现问题。</li>
</ol>

<p>这三个问题，最容易的是第二个，只要保证在同一分辨率的设备上播放即可。<br />
第一个问题，我们需要和服务器同学沟通，让他对关卡做一个镜像。开发成本较高。只好放弃。<br />
最后我们在开发模式下，通过客户端的缓存，将服务器的数据全部保存下来。回放的时候，完全是客户端在自己播放。将与服务器请求的数据也缓存起来。虽然开发成本高了，但是基于此，没有任何网络请求的压力，第三个问题也有了解决方案。<br />
第三个问题还涉及性能问题，要快速解决，我们想到的是用一台高端配置的设备，或者直接在模拟器上播放。</p>

<p>至此大问题都已经解决，剩下的就是如何实现回放了。</p>

<h3 id="cocos2dxconsole">cocos2dx提供的console为基础</h3>

<p>在cocos2dx 3.x版本，增加了一个<code>Console</code>功能。提供的基本功能如下：</p>

<pre><code>
{
    createCommandAllocator();
    createCommandConfig();
    createCommandDebugMsg();
    createCommandDirector();
    createCommandExit();
    createCommandFileUtils();
    createCommandFps();
    createCommandHelp();
    createCommandProjection();
    createCommandResolution();
    createCommandSceneGraph();
    createCommandTexture();
    createCommandTouch();
    createCommandUpload();
    createCommandVersion();
}
</code></pre>
<p>在项目中增加对端口5678的监听即可。</p>

<p>lua代码：</p>

<pre><code>cc.Director:getInstance():getConsole():listenOnTCP(5678)
</code></pre>

<p>c++代码</p>

<pre><code>auto console = director-&gt;getConsole();
console-&gt;listenOnTCP(5678);
</code></pre>

<p>项目启动之后，打开终端：</p>

<pre><code>nc localhost 5678
</code></pre>

<p>如果是在手机上启动，则需要手机和电脑连在同一个局域网之内。然后查看手机的ip地址。替换上面的localhost。</p>

<p>敲入命令之后，终端显示connect success。然后输入<code>help</code>。此时cocos2dx提供的定制命令全会罗列出来。</p>

<p>而我们要使用的就是<code>touch</code>命令。</p>

<h3 id="section-1">保存点击位置和回放</h3>

<p>保存的位置，应该是什么位置呢？</p>

<p>因为我们使用的是touch命令，而他需要的位置信息，是以设备坐标系为准的。也就是原点坐标在左上角为准。而cocos2dx的坐标系是以opengl为准，左下角是原点。</p>

<p>所以我们要将点击的opengl坐标转为设备坐标。<br />
这个转换，cocos2dx也提供了对应的接口。代码如下：</p>

<pre><code>Vec2 Director::convertToGL(const Vec2&amp; uiPoint)
{
    Mat4 transform;
    GLToClipTransform(&amp;transform);
    ...
    return Vec2(glCoord.x * factor, glCoord.y * factor);
}

Vec2 Director::convertToUI(const Vec2&amp; glPoint)
{
    Mat4 transform;
    GLToClipTransform(&amp;transform);
		...
    return Vec2(glSize.width * (clipCoord.x * 0.5f + 0.5f) * factor, glSize.height * (-clipCoord.y * 0.5f + 0.5f) * factor);
}
</code></pre>

<p>所以记录点击位置的代码很简单：</p>

<pre><code>local posx,posy = node:getPosition()
local pos = node:getParent():convertToWorldSpace(cc.p(posx,posy))
local director = cc.Director:getInstance()
local uiPos = director:convertToUI(pos)
</code></pre>

<p>记录位置，然后保存。大功完成一半。是不是很简单。</p>

<p>接下来说一下回放。<br />
回放是自动完成，也就意味有一个定时器，定时将位置信息触发。<br />
我的做法是使用<code>python</code>结合<code>nc</code>，<code>touch</code>命令，将位置信息挨个触发。</p>

<p>python可以调用系统命令。我们使用adb命令将保存的位置信息文件读出来，然后<code>nc连接</code>游戏。在nc命令模式下，调用<code>touch</code>命令。</p>

<pre><code>touch swipe 300 400 300 400
</code></pre>

<p>这里touch有一个bug，就是对单点的支持不正确，点击并未触发。于是我尝试使用了多点。就是传递了同一个位置。竟然可以使用。</p>

<p>python代码如下：</p>

<pre><code>nc = Netcat(server_address, 5678)
while(index &lt; len(recordArray)):
    nc.read_until('&gt;')
    item = recordArray[index]
    cmd = "touch swipe %d %d %d %d \n"  % (item[0],item[1],item[0],item[1])
    nc.write(cmd)

    index = index + 1
    time.sleep(4)
</code></pre>

<h3 id="section-2">结语</h3>

<p>至此这个工具的制作过程都讲完了。期间也掉进了坑中，幸运的是和其他同事交流下，脑袋就清晰了一些。慢慢的我的这个大坑也就填上了。<br />
实践过程中也存在一些问题。也在慢慢优化中。期望有一天成熟起来，能给其他项目中带来便利。<br />
<img src="http://7xuepc.com1.z0.glb.clouddn.com/2017-10-08-15074549225204.jpg" alt="" /></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[cocos2dx游戏性能优化技巧]]></title>
    <link href="http://www.newtomato.me/blog/2017/10/06/cocos2dxxing-neng-you-hua"/>
    <updated>2017-10-06T22:09:58+08:00</updated>
    <id>http://www.newtomato.me/blog/2017/10/06/cocos2dxxing-neng-you-hua</id>
    <content type="html"><![CDATA[<p>手机游戏性能优化主要有两个方面。一个CPU，一个GPU。</p>

<p>GPU主要用于图像渲染方面。由于现在显卡发展迅速。原本CPU的部分功能，可以转移到GPU上计算运行。这样大大的减轻了CPU的运算压力。提升效率。</p>

<p>GPU和CPU都有各自的性能指标。我们最常优化的地方都是CPU，因此我先从这一部分讲起。<br />
<img src="http://7xuepc.com1.z0.glb.clouddn.com/2017-10-06-15073018470041.jpg" alt="" /><br />
我给你演示一下我做的项目！这…,肯定是环境的问题！<br />
<!--more--></p>

<h3 id="cpu">CPU有关的方法</h3>

<p>cocos2dx在开启debug模式之后，在左下角有三行debug信息。<code>GL vertical</code>，<code>draw call</code>，以及<code>fps</code>.<br />
fps是最常用的指标之一。数值越高游戏运行越流畅。他表示一秒钟能刷新多少帧。<br />
draw call也是性能优化的指标。他表示需要几次draw才能把图片展示出来。<br />
gl vertical不常用，但是也是优化指标之一，他表示当前有多少个顶点数据。</p>

<p>所有的方法就是围绕这三个指标开始展开。</p>

<ol>
  <li>使用<code>batchnode</code>批处理的方式加载图片。因此cocos2dx在这方面做了优化，在同一个<code>batchnode</code>的图片会一次性draw到GPU上，从而降低<code>draw call</code>的调用。从cocos2dx 3.0以后的版本，cocos2dx自动使用batchnode技术，而不需要开发者自己创建。</li>
  <li><code>fps</code>的降低是因为有大量数据的计算，例如对象的生成。因此考虑对象池技术。例如cocos2dx使用的<code>AnimaitonCache</code>，<code>TextureCache</code>，<code>SpriteFrameCache</code>等。例如我们创建很多敌人。敌人消亡之后又会重新创建。实际上可以放到对象池中，默认从池中获取，如果池子里面没有对象，在重新创建。</li>
  <li>加载较大资源，瞬间fps会下降很多。那是因为这个过程是加载图片资源和解析动画数据创建对象。动画资源最好提前加载。
    <ol>
      <li>按照由大到小的顺序加载。加载大的资源会和内存申请资源2倍的内存。但加载完什么时候不会立即释放。接着在依次加载。此时内存已经被撑大，在加载资源也可能不在需要申请新的内存了。</li>
      <li>io读取动画数据信息，使用缓存，这点在cocos studio制作的armature中已经使用。但是Spine动画并未如此。他会每次创建都会重新加载。</li>
      <li>可以用序列帧动画代替复杂的需要计算的动画。序列帧动画资源比较大。加载后压力转嫁给gpu而非cpu。</li>
    </ol>
  </li>
  <li>减少粒子动画的使用。</li>
  <li>图片加载之后，为什么会占据那么高的内存？一张1024x1024的RGB8888，大小200k的图片，加载后，占内存4M，因为图片本身是压缩的数据。在内存中都会被解压缩膨胀起来。他先被CCImage读取解析（它实现了对于不同类型图片得读取、解析、像素信息保存），然后CCTexture2D在根据CCImage又创建了一份数据。因此内存会有2倍的开销，如果我们可以使用gpu直接解析的图片，比如ios平台的pvr tc4格式，或者android的etc格式，则内存只有1倍左右的开销。</li>
  <li>上述提到的pvr tc4格式，也有自己的缺点，它是有损压缩。肉眼可以看得出来，因此只能用于细微的地方。比如特效或者粒子等。</li>
</ol>

<h3 id="gpu">GPU有关的方法</h3>

<p>GPU的优化则要分情况而定。</p>

<p>GPU早期的架构和PC相似，都是IMR（Immediate Mode Rendering），这种架构的GPU渲染有个问题，就是Overdraw过高。因为他将被遮挡的物体也被draw到显卡上。这明显是一种浪费。<br />
现在的GPU在一定程度上可以避免这个问题，但是需要应用程序将物体按照z轴顺序从前往后的顺序提交给GPU，这是一种方案。<br />
另外，现在GPU有三家大的厂商。分别是<code>powervr，高通Adreno，ARM mali</code>。他们采用的是TBR（分块渲染）的架构。在overdraw方面，<code>powervr</code>是做得最好的一家。他使用<code>TBDR（Tile Based DeferredRendering）</code>架构，他增加了一个<code>HSR（Hidden Surface Removal)</code>硬件单元，剔除掉被遮挡的三角形。</p>

<p>因此说GPU的优化分情况而定。而为了降低遮挡，在我们开发游戏中可以通过TexturePacker的多边形裁剪来做到。<br />
说着这个，最常见的情况是有透明的图片，透明也是像素，也需要被读取到显卡上，增加带宽的浪费。而多边形裁剪就是将透明的部分裁掉。<br />
<img src="http://7xuepc.com1.z0.glb.clouddn.com/2017-10-06-15072972637518.jpg" alt="=w300" /></p>

<p>使用cocos2dx打开<code>CC_SPRITE_DEBUG_DRAW</code>,此时你可以看到一个<code>Sprite</code>的三角形不再是两个。而是多个。<br />
但同时，我们也发现他的<code>gl vertcail</code>也变得很大。顶点越多，cpu计算越多。而我们使用了这种多边形裁剪，期初是为了降低GPU的计算和渲染。却带来了另一个问题。</p>

<p>因此又回到那种时间换取空间的问题。可根据具体情况考虑是否使用这种方法。<br />
不过，经过测试这种方法在powervr型号的gpu设备上没有多少成效。</p>

<h3 id="section">其他技巧</h3>

<ol>
  <li>善用dumpCachedTextureInfo，找到那些texture一直未被释放。</li>
  <li>对于只是使用一次的texture，在加载到gpu之后，可以remove内存对他的引用。这不会产生问题。</li>
  <li>善于使用九宫格，降低对同一种资源的频繁加载。</li>
  <li>早期手机部分不支持npot，为了统一资源，都做成了pot的格式，浪费了资源。现在手机大都已经支持npot。所以texturepacker导出可以选择npot，最新的npot的版本已经是anysize了。</li>
  <li>数字字体尽量使用bmffont。</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[认识liquidFun（流体物理引擎）]]></title>
    <link href="http://www.newtomato.me/blog/2017/06/25/ren-shi-liquidfun"/>
    <updated>2017-06-25T23:24:41+08:00</updated>
    <id>http://www.newtomato.me/blog/2017/06/25/ren-shi-liquidfun</id>
    <content type="html"><![CDATA[<p><img src="http://7xuepc.com1.z0.glb.clouddn.com/2017-06-25-14984044203691.png" alt="" /></p>

<h2 id="section">初识</h2>

<p>在一款名为<a href="http://fingerlab.net/portfolio/yuri">《yuri》</a>的游戏中，发现了点有意思的东西，于是乎各种搜索，终于找到了相关的技术，那就是由google开源的物理引擎<a href="http://google.github.io/liquidfun/">liquidFun</a>。</p>

<p><code>liquidFunc</code>的demo地址<a href="http://google.github.io/liquidfun/testbed/index.html">在此</a>。相信我你看到这个demo之后，绝对会对<code>liquidFun</code>这个引擎产生无比的喜欢。（这里不需要翻墙，只要能打的开github，就能够看得到这个演示。）</p>

<p>先来一睹为快！<br />
<img src="http://7xuepc.com1.z0.glb.clouddn.com/2017-07-02-Untitled.gif" alt="" /></p>

<!--more-->

<p><strong>他</strong>继承自<strong>Box2D</strong>，是Box2D的扩展版本，但增加了粒子的流体和柔软性效果。<br />
<a href="http://google.github.io/liquidfun/API-Ref.html">相关的API文档</a><br />
<a href="http://docs.google.com/presentation/d/1fEAb4-lSyqxlVGNPog3G1LZ7UgtvxfRAwR0dwd19G4g/edit?usp=sharing">具体的实现细节在这里</a></p>

<p>因为支持C++, Java, or JavaScript，因此可以整合到cocos2dx引擎中。方便我们使用。当我想到这里的时候，立马去github上搜索了一下。果然触控已经开始考虑到这点了。</p>

<h2 id="section-1">了解</h2>

<p>于是在github触控这里，找到了一份<a href="https://github.com/cocos2d/cocos2d-x-samples">cocos2dx整合liquidFunc的实例工程。</a></p>

<p>安装方法如下:</p>

<pre><code>git clone https://github.com/cocos2d/cocos2d-x-samples
cd cocos2d-x-samples
python download-engine.py
git submodule init
git submodule update
</code></pre>

<p>执行完上述步骤，就可以在sample中打开<code>LiquidFun - EyeCandy</code>工程了。效果也是震撼。<br />
完全足够我们的使用了。</p>

<p>这个工程的作者<a href="https://github.com/ricardoquesada">Ricardo Quesada</a>在他的的博客中有两篇文章，讲解了整合cocos2dx和liquidFun的细节。</p>

<ul>
  <li>
    <p><a href="https://retro.moe/2014/04/23/integrating-liquidfun-with-cocos2d-x-part-i/">Integrating LiquidFun with Cocos2d-x: Part I</a></p>
  </li>
  <li>
    <p><a href="https://retro.moe/2014/07/30/integrating-liquidfun-with-cocos2d-x-part-ii/">Integrating LiquidFun with Cocos2d-x: Part II</a></p>
  </li>
</ul>

<p>感兴趣的各位同学不妨移步去看看，加深对liquidFunc的理解。</p>

<h2 id="section-2">下一步</h2>

<p>由于我们的项目使用的cocos2dx + lua，因此下一步要考虑的就是通过luabing将<strong>Box2D</strong>和<strong>liquidFunc</strong>的代码注册到lua虚拟机中使用。这部分我将在下一篇文章中讲解。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Cocos2dx和OBB的结合使用]]></title>
    <link href="http://www.newtomato.me/blog/2016/11/20/cocos2dxhe-obbde-jie-he-shi-yong"/>
    <updated>2016-11-20T18:04:13+08:00</updated>
    <id>http://www.newtomato.me/blog/2016/11/20/cocos2dxhe-obbde-jie-he-shi-yong</id>
    <content type="html"><![CDATA[<p>上一篇文章我们讲到OBB文件的下载，但是没有说到如何使用。这一篇文章就讲解一下怎么使用。<br />
有两种方法可以使用OBB文件。<br />
<img src="http://7xuepc.com1.z0.glb.clouddn.com/2016-11-20-2311393916-0.jpg" alt="=w300" /></p>

<h3 id="section">方法比较</h3>

<ul>
  <li>第一种方法，obb文件也是一种ZIP文件，我们可以解压缩obb文件，</li>
  <li>第二种方法，直接读取obb文件。<code>getFileDataFromZip</code>这样的方法就可以。</li>
</ul>

<p>这两种方法各有优缺点。<br />
第一种方法将文件解压缩到<code>getWritablePath()</code>文件夹下面。然后此路径<code>addSearchPath</code>到搜索路径中，我们不需要修改其他的代码就可以读取了。缺点是我们需要有一个解压缩的过程。尤其是obb过大的时候，解压缩耗费的时间也会很长。另外解压缩之后，请不要删除obb文件，否则下次进入，又要重新下载。另外这种方式还破坏了obb的加密性。另外这种方法是可行的，但Google并不推荐这种方式。<br />
第二种方式则需要修改部分c++代码。</p>

<p>因此我采用了第二种方法，对CCFileUtil做了一些修改。（主要说一下除了音效音乐之外的使用。）<br />
CCFileUtil是一个基类，在Android平台我们主要关注的是CCFileUtilAndroid.cpp文件。<br />
<!--more--><br />
### 方法梳理</p>

<p>CCFileUtil主要功能是检查一个文件是否存在，能否读取文件的内容。而我们把部分资源文件放到了obb之中，CCFileUtil需要知道这个地方，才能够从那里读取。</p>

<p>在java层，我们知道我们的obb存储的位置是在</p>

<pre><code>	int versionCode = "项目的versionCode"
	String apkName = Helpers.getExpansionAPKFileName(sContext,true,versionCode);
	return Helpers.generateSaveFileName(sContext,apkName);
</code></pre>

<p>通过JNI，将这个路径${obbPath}传递给c++，可以参考<code>CCFileAndroid.cpp</code>里面的<code>getApkPath()</code>函数。</p>

<pre><code>std::string resourcePath = getApkPath();
s_pZipFile = new ZipFile(resourcePath, "assets/");        
</code></pre>
<p>类似s_pZipFile，我们也生成一个${obbZipFile}，用于文件的查找。</p>

<p>然后将此路径<code>addSearchPath</code>到搜索路径中。通过阅读CCFileUtil.cpp文件我们得知检查一个文件的全路径主要是检测<code>isFileExist</code>函数。如果他证明存在此文件，就能获取到全路径。</p>

<pre><code>fullPathForFilename--&gt;getPathForFilename--&gt;getFullPathForDirectoryAndFilename--&gt;isFileExist
</code></pre>

<p>因此我们修改isFileExist文件，在里面根据文件的路径检查是否在。伪代码如下：</p>

<pre><code>bool CCFileUtilsAndroid::isFileExist(const std::string&amp; strFilePath)
{
	...
    bool bFound = false;

    if (strFilePath.find(${obbPath}) != std::string::npos)
    {
        if (${obbZipFile} &amp;&amp; ${obbZipFile}-&gt;fileExists(strPath))
        {
            bFound = true;
        } 
    }
	...
}
</code></pre>

<p>上面我们把obb文件做成了ZipFile对象，因此在doGetFileData中，就很容易得到文件的内容。伪代码如下：</p>

<pre><code>unsigned char* CCFileUtilsAndroid::doGetFileData(const char* pszFileName, const char* pszMode, unsigned long * pSize, bool forAsync)
{
    unsigned char * pData = 0;
    
...
    string fullPath = fullPathForFilename(pszFileName);
   
    // 获取obb文件
    if (${obbZipFile} &amp;&amp; fullPath.find(${obbPath}) != std::string::npos){
        
        if (forAsync)
        {
            pData = ${obbZipFile}-&gt;getFileData(fullPath.c_str(), pSize, ${obbZipFile}-&gt;_dataThread);
        }
        else
        {
            pData = ${obbZipFile}-&gt;getFileData(fullPath.c_str(), pSize);
        }
    }
    ...
  }

</code></pre>

<h3 id="section-1">总结语</h3>

<p>至此我们就能够读取obb里面的内容了。<br />
我的方法基于将obb看成了ZIP，模仿apk的方式去读取文件。将obb位置放到了搜索路径。ZIP对象存在且能够从里面读取文件，则表明文件存在。就可以读取他了。</p>

<p>这里面设计到JNI传递数据。其实这对于我们只要仿照APK路径传递就可以了。关于JNI具体的实现，还请看下一章节内容。</p>

<p>感谢你的阅读！</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[cocos2dx 增加Google移动广告]]></title>
    <link href="http://www.newtomato.me/blog/2016/07/18/zheng-he-google-ads"/>
    <updated>2016-07-18T22:13:43+08:00</updated>
    <id>http://www.newtomato.me/blog/2016/07/18/zheng-he-google-ads</id>
    <content type="html"><![CDATA[<p>Google 提供一套广告的SDK，方便开发者将自己在自己应用中植入广告。国内不少的厂家也在做这样的SDK，比较有名的就是触控下面的AnySDK。<br />
<img src="http://7xuepc.com1.z0.glb.clouddn.com/2016-07-18-any.jpeg" alt="any" /></p>

<p>但是AnySDK是一个大而全的东西，而我们只需要广告接入这一小块儿的东西。同时，我们的cocos2dx的版本是2.2.6，相对于触控的3.18，已经有很大差别。</p>

<p>于是我们需要自己在重新造一遍轮子，幸运的是网上有不少这样的材料。</p>

<ol>
  <li>Firebase提供的文档刚好有与cocos2x相关的资料，<a href="https://firebase.google.com/docs/admob/android/games?hl=zh-cn">移步至此</a>,</li>
  <li>还有热心的同学贴出了更详细的步骤<a href="http://www.cnblogs.com/qianyuming/p/5023018.html">cocos2dx-3.9 集成admob</a>。</li>
  <li>
    <p><a href="https://firebase.google.com/docs/admob/ios/quick-start?hl=zh-cn">入门基础指导</a><br />
<!--more--><br />
参考了上面的资料，我还是遇到了不少问题。</p>
  </li>
  <li>
    <p>首当其冲的就是<strong>安装CocoaPods</strong> ，可以参考下面两篇文章。</p>

    <ol>
      <li><a href="http://blog.csdn.net/wuquan0625/article/details/47401235">pod install速度慢的终极解决方案</a>。</li>
      <li><a href="http://www.cnblogs.com/qianyuming/p/5012578.html">cocoapod安装过程中的幺蛾子</a></li>
    </ol>
  </li>
  <li>一定要下载最新的googlemobilesdk版本，<a href="https://firebase.google.com/docs/admob/ios/download?hl=zh-cn">地址在此处</a>,我当前用的是v7.9.0。</li>
  <li>我们的项目不仅仅会依赖上面的<code>GoogleMobileAds.framework</code>，还依赖一下的framework，请在target-&gt; build phase -&gt; frameworks中找出来。此处我也是被坑到了，总是提示类似<code>"_OBJC_CLASS_$_SFSafariViewController", referenced from: "_CMTimeMakeWithSeconds", referenced from: l3880 in GoogleMobileAds(flat-arm64)"</code>这样的错误，究其原因就是没有找到对应的framework。</li>
</ol>

<pre><code>CoreMideia.framework,SafariServices.framework,
CoreBluetooth.framework,MessageUI.framework,
AdSupport.framework,EventKit.framework,EventKitUI.framework,
AudioToolbox.framework,MediaPlayer.framework,
StoreKit.framework,SystemConfiguration.framework,
CoreTelephony.framework,CoreGraphics.framework,
AVFoundation.framework
</code></pre>

<ol>
  <li>clean-&gt;build project</li>
  <li>在模拟器上运行，Google Ads会自动加载测试的广告。但是如果要在真机上测试，需要打开真机上关闭广告跟踪的功能。在手机的设置-&gt;隐私-&gt;广告里面。关闭即可。</li>
  <li>运行项目从输出控制台先拿到测试设备号。然后填写到下面的位置。再次运行。</li>
</ol>

<pre><code>GADRequest *request = [GADRequest request];
request.testDevices = @[@"测试设备号"];
</code></pre>
<ol>
  <li>设备上测试，还要考虑装一个VPN。</li>
  <li>如果首次没有显示出来，并且控制台也没有报错，估计就是网络响应慢导致的问题。可以多次尝试即可。</li>
  <li>Google 提供了一个example工程。<a href="git@github.com:googleads/googleads-mobile-ios-examples.git">地址</a>,可以先调通这个工程，那么整合到cocos2dx中也就不是什么事儿了！</li>
</ol>

<p>上述是我花费了大半天的时间，踩了不少坑，才将这套流程走通。并且仅仅是展示了Banner广告。<br />
先看一下效果吧。接下来的计划就是调通控制广告播时长的接口。</p>

<p><img src="http://7xuepc.com1.z0.glb.clouddn.com/2016-07-18-IMG_0511.png" alt="IMG_0511" /></p>

]]></content>
  </entry>
  
</feed>
