<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[番茄手册]]></title>
  <link href="http://www.newtomato.me/atom.xml" rel="self"/>
  <link href="http://www.newtomato.me/"/>
  <updated>2017-04-15T15:07:07+08:00</updated>
  <id>http://www.newtomato.me/</id>
  <author>
    <name><![CDATA[newtomato]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[require机制和自动更新之间的爱恨情仇]]></title>
    <link href="http://www.newtomato.me/blog/2017/04/15/requirehe-re-geng"/>
    <updated>2017-04-15T15:02:02+08:00</updated>
    <id>http://www.newtomato.me/blog/2017/04/15/requirehe-re-geng</id>
    <content type="html"><![CDATA[<p>lua之所以能够做自动更新，和require的特殊机制有很大的关系。<br />
通过阅读require相关的代码，我们得知，require的原理是先从<code>package.loaded</code>当中先检查是否存在要加载的lua文件，如果不存在则读取之后放入到<code>package.loaded</code>中，如果存在直接将从<code>package.loaded</code>中读取即可。<br />
因此我们热更新之后，为了能够让新的文件生效，会将<code>package.loaded</code>直接清空。这样按照上面的逻辑，<code>require</code>进来得文件肯定都是新的文件了。</p>

<p>事实是，总有意想不到的事情发生。<br />
<img src="http://7xuepc.com1.z0.glb.clouddn.com/2017-04-15-805c3d47ly1fdoys4g14mg209q05g4jr.gif" alt="805c3d47ly1fdoys4g14mg209q05g4j" /></p>

<!--more-->

<p>但是事实上这里面暗藏了小小的机关。<br />
那就是如何清空<code>package.loaded</code> ?</p>

<p>有两种情况清空的方法。</p>

<p>第一种：<br />
<code>package.loaded = {}</code></p>

<p>这种方式之后，热更的文件是否生效了呢？我们发现没有生效照样还是返回以前的lua模块了。所以这种方法没有达到我们理想的清空啊。</p>

<p>第二种方法：</p>
<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class=""><span class="line">for k,v in pairs(package.loaded) do
</span><span class="line">	package.loaded[k] = nil
</span><span class="line">end</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这两种看起来没什么区别，但是第二种起作用了。重新加载文件，生效的是新的lua模块。</p>

<p>仔细看看这两种方法，第一种其实并未真的清空，他是将package.loaded的指向的对象地址发生了变化，原先内存中存在的那份加载对象还是存在的。也就是对象并未释放，导致加载未生效。而第二种则是对加载对象这块儿内存数据直接清理。因此重新加载的时候肯定生效。</p>

<p>因此对象引用这块儿，一定要切记小心。不要被他简单的外表欺骗了。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[记最近遇到最头疼的一个Bug]]></title>
    <link href="http://www.newtomato.me/blog/2017/03/12/ji-zui-jin-yu-dao-zui-tou-teng-de-bug"/>
    <updated>2017-03-12T16:15:46+08:00</updated>
    <id>http://www.newtomato.me/blog/2017/03/12/ji-zui-jin-yu-dao-zui-tou-teng-de-bug</id>
    <content type="html"><![CDATA[<h3 id="section">前记</h3>

<p><img src="https://cdn.ruguoapp.com/FkHR-5cSU8UK1upmG4x67UQCKWZI" alt="" /><br />
这个将要说的bug并不复杂，但是却影响了一大波的用户。后果很严重。而引发这个问题的原因却是错综复杂，千丝万缕。<br />
只能说一坑还有一坑深。<br />
<!--more--></p>

<h3 id="section-1">问题背景交代</h3>

<p>问题的背景是这样的，我们在开发过程中，从主干开了一个分支，针对Google平台做优化，然后基于某些原因，这些优化的提交一直没有合并回主干分支。<br />
为此我们相当于保持了两个主干，每种功能都会在这两个分支都做合并。每次发布热更新，都需要发布两种情况，一种是主干分支的更新，一种是专门针对Google的更新。</p>

<p>直到某一天，我们决定再次出一个完整的apk包，提交给平台，负责出APK包的同事，以Google为准做了包，因为我们分析发现Google是比较完整的代码，且对底层做了部分优化，是没有问题的。并且当时测试APK没有任何问题。</p>

<p>但是这样做了之后，我们却忘记将Google 分支的优化提交合并到真正的主干。导致这部分代码丢失。这是最大的错误。比如当时有个类文件A，里面原先有个函数<code>doAction()</code>,但是在主干上他没有这个函数。</p>

<h3 id="section-2">问题开始发生了</h3>

<p>这之后，我们又有新的功能，准备热更新出去。于是这里面的更新在新的APK包里面出现了问题。出问题的正式上面的A文件，A被更新出去，但是A没有这个函数，导致原先调用这个文件的地方都报错。</p>

<p>到此，你们会疑问，为什么测试没有发现呢？那是因为这中触发bug的情况很特殊，并不是百分百触发。所以比遗漏了。</p>

<p>当时已经发现了问题的根本原因，于是便从何合并优化提交，做成热更发出了。</p>

<p>以为问题到此结束，哎。</p>

<h3 id="section-3">问题开始发生了</h3>

<p>之后我们发现部分用户突然进不去游戏了，止步于游戏的启动页面，然后就崩溃。</p>

<p>这可头疼死了，只能知道是客户端崩溃，服务器还没有收到任何的请求。可以连接<code>monitor</code>也没有任何特殊的提示。<br />
幸运的是，在新出的APK包上没有这个问题，只在旧有的APK上才有这种问题。这也是背景之一，我们的整包APK更新，并不是强制要求用户更新。于是外面有的时候会出现一个平台多个整包。<br />
在这一点线索的情况的下，我们最终发现此次合并的优化提交有一部分是对字体的优化。刚好字体默认名字做成了配置。而初始化字体配置的地方在优化中移动到了一个敏感的文件中。这个文件只会在出整包的时候才有用，在自动更新的时候，是不会更新出去的。这是早期的约定。历史已经被遗忘。竟然没有人记得了。</p>

<p>问题正是在这里，老的APK由于没有这个字体配置的初始化，导致面板全部崩溃。用户自然进不去了。</p>

<h3 id="section-4">后记</h3>

<p>这次问题，是我们开发流程出现了问题，本身可以避免。这让我反思了许久。我们存在的问题。</p>

<ol>
  <li>平台版本管理混乱，依靠人工记忆。没有任何地方记录当前那些版本可以用。</li>
  <li>合并代码竟然没有提前做。没有对更新做充分考虑。</li>
  <li>测试不充分。</li>
  <li>没有收集crash崩溃的日志系统。这样我们在发生了问题的时候束手无策。</li>
</ol>

<p>问题带来的教训虽然惨痛，但是为此我们亡羊补牢，时刻注意。尽量避免下次再掉进同样的坑里。</p>

<p>而此刻我的心情：<br />
<img src="https://cdn.ruguoapp.com/FgXsKJOSxZSKIyRVLlhA1TuhcyGW" alt="" /></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用Android Studio制作多个渠道包]]></title>
    <link href="http://www.newtomato.me/blog/2017/01/10/shi-yong-android-studiozhi-zuo-duo-ge-qu-dao-bao"/>
    <updated>2017-01-10T20:24:50+08:00</updated>
    <id>http://www.newtomato.me/blog/2017/01/10/shi-yong-android-studiozhi-zuo-duo-ge-qu-dao-bao</id>
    <content type="html"><![CDATA[<p>以前制作多个渠道包的方法是这样子的，在AndroidMenifest.xml里面放置一个的变量。例如</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">&lt;meta-data android:name="dksdk_channel" android:value="CHANNEL_CHANNEL_VALUES" /&gt;
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>然后对生成的apk分析，替换里面的SETTING_UMENG_CHANNEL_CHANNELID_VALUES，重新打包就可以了。</p>

<p>这段时间从Eclipse迁移到android studio上面，发现android studio里面有<code>flavor</code>的一个特殊存在，不太了解，Google了一下，发现这个东西正好可以解决我们多平台制作apk的需求。<br />
<img src="http://7xuepc.com1.z0.glb.clouddn.com/2017-01-10-14840497981415.jpg" alt="-w250" /><br />
<!--more--><br />
接下来直奔主题吧！<br />
首先，我们在AndroidManifest.xml文件中定义一个变量<code>"${channcelValue}"</code>。<br />
其次，打开工程对应的Setting设置<img src="http://7xuepc.com1.z0.glb.clouddn.com/2017-01-10-14840500315961.jpg" alt="" /><br />
在中间空白列下面点击+依次添加渠道，右侧对应的就是平台的特殊性。比如有的平台有自己的特殊包名，可以修改Application Id,这样编译之后，此id会替换androidmanifest里面的包名。<br />
第三，打开工程对应的build.gradle文件，你会发现里面多了个<code>productFlavors</code>的配置，刚好是你刚刚配置的东西。在对应的每个平台或者渠道下面，增加<code>manifestPlaceholders = [platformValue:1]</code>。<br />
我的配置如下：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
</pre></td><td class="code"><pre><code class=""><span class="line">   productFlavors {
</span><span class="line">        platform_1 {
</span><span class="line">            manifestPlaceholders = [platformValue: "平台1号"]
</span><span class="line">            minSdkVersion 15
</span><span class="line">            targetSdkVersion 15
</span><span class="line">        }
</span><span class="line">        platform_2 {
</span><span class="line">            manifestPlaceholders = [platformValue: "平台2号"]
</span><span class="line">            minSdkVersion 11
</span><span class="line">            targetSdkVersion 11
</span><span class="line">        }
</span><span class="line">        platform_3 {
</span><span class="line">            manifestPlaceholders = [platformValue: "平台3号"]
</span><span class="line">            minSdkVersion 11
</span><span class="line">            targetSdkVersion 11
</span><span class="line">        }
</span><span class="line">        platform_4 {
</span><span class="line">            manifestPlaceholders = [platformValue: "平台4号"]
</span><span class="line">            minSdkVersion 11
</span><span class="line">            targetSdkVersion 11
</span><span class="line">        }
</span><span class="line">    }	</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>大功告成！</p>

<p><strong>PS:</strong><br />
但是这样之后，发现每次debug，都是debug某一个平台，如何指定debug特定的平台？继续Google，发现在android studio左下角，有一个<code>build variants</code>的地方，点开，就可以选择你想要debug的平台了。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[常用工具网站汇集-不定期更新中]]></title>
    <link href="http://www.newtomato.me/blog/2017/01/09/chang-yong-gong-ju-wang-zhan-hui-ji-bu-ding-qi-geng-xin-zhong"/>
    <updated>2017-01-09T15:08:23+08:00</updated>
    <id>http://www.newtomato.me/blog/2017/01/09/chang-yong-gong-ju-wang-zhan-hui-ji-bu-ding-qi-geng-xin-zhong</id>
    <content type="html"><![CDATA[<ol>
  <li><a href="https://apptut.gitbooks.io/android-note/content/common_tools/use_gradle.html">Android笔记</a></li>
  <li><a href="http://www.liaoxuefeng.com/">廖雪峰的官方网站</a></li>
  <li><a href="https://leohxj.gitbooks.io/a-programmer-prepares/content/index.html">程序员的自我修养</a></li>
  <li><a href="https://www.zilongshanren.com/">子龙山人</a></li>
  <li><a href="https://git-scm.com/book/ch7-1.html">GIT手册</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[keytool的基本用法以及检查apk签名]]></title>
    <link href="http://www.newtomato.me/blog/2017/01/09/keytoolde-ji-ben-yong-fa-yi-ji-jian-cha-apkqian-ming"/>
    <updated>2017-01-09T14:38:22+08:00</updated>
    <id>http://www.newtomato.me/blog/2017/01/09/keytoolde-ji-ben-yong-fa-yi-ji-jian-cha-apkqian-ming</id>
    <content type="html"><![CDATA[<p>要导出正式的android的apk，就需要用得到一个keystore的文件。这个文件就是由keytool生成的一个文件。</p>

<p><code>Keytool</code> 是一个JAVA环境下的安全钥匙与证书的管理工具，用于生成一个证书管理库，用于管理私钥公钥验证相关的一个证书keystore。<br />
你可以把keystore看成是一个数据库，里面存储的是证书，keytool就是用来操作这个数据库的工具！<br />
<!--more--><br />
他常用的命令有以下几种方式。</p>

<ol>
  <li>
    <p>创建keystore<br />
<code>keytool -genkeypair -alias "android" -keyalg "RSA" -keystore "mylib.keystore"  </code></p>

    <p>创建一个别名为<code>android</code>的证书，该证书存放在名为<code>mylib.keystore</code>的密钥库中.<br />
 <code>-alias</code>指明这是证书的别名，同时也是秘钥对的别名。</p>
  </li>
  <li>查看keystore<br />
  <code>keytool -list -keystore mylib.keystore</code></li>
  <li>导出keystore里面的证书<br />
 <code>keytool -export -alias android -file android.crt -keystore mylib.keystore</code></li>
  <li>查看导出的证书信息<br />
 <code>keytool -printcert -file "android.crt"</code></li>
  <li>删除keystore里面的证书<br />
 <code>keytool -delete -keystore mylib.keystore -alias android</code></li>
</ol>

<p>另外，keytool最有用的的方法是检查apk的签名和验证。<br />
检查apk签名方法有两种一种是将apk解压缩，找到里面的<code>META-INF</code>文件夹。然后对其RSA文件进行如下命令即可:<br />
<code>keytool -printcert -file META-INF/XXXX.RSA</code><br />
第二种方法，在不加压缩的情况下<br />
<code>keytool -list -printcert -jarfile xxx.apk</code><br />
但是jarfile是java 7才引入，所以如果自己电脑里面的java版本不足，需要升级。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android facebook登录问题]]></title>
    <link href="http://www.newtomato.me/blog/2017/01/07/android-facebookdeng-lu-wen-ti"/>
    <updated>2017-01-07T19:31:06+08:00</updated>
    <id>http://www.newtomato.me/blog/2017/01/07/android-facebookdeng-lu-wen-ti</id>
    <content type="html"><![CDATA[<p>如果应用通过web方式登录fb，没有出现问题，但是通过fb应用登录反而报错，报错信息如下：<br />
<code>Android hash key always does not match any stored key hashes</code></p>

<p>这个时候，怎么解决呢？<br />
<!--more--><br />
我在这个<a href="http://stackoverflow.com/questions/22818516/android-facebook-api-key-hash-not-match-any-store-key-hashes">stackoverflow</a>下面找到了解决方法。</p>

<p>总结起来的方法就是，fb会弹出提示告诉你，你应用的hash值和我们存储的不一致。我们记下这个hashcode，然后到fb developer console那里设置<code>key Hashes</code><br />
<img src="http://7xuepc.com1.z0.glb.clouddn.com/2017-01-07-14837800858205.jpg" alt="-w400" /></p>

<p>但是这个key hashes值是怎么创建的呢？<br />
一番搜索之后，在<a href="https://github.com/AntonioCuevaUrraco/nativescript-facebook-login/issues/14">这里</a>找到了答案</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">keytool -exportcert -alias androiddebugkey -keystore ~/.android/debug.keystore | openssl sha1 -binary | openssl base64</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>命令运行了之后，果然和上面的一样。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JNI,java和C++之间的桥梁]]></title>
    <link href="http://www.newtomato.me/blog/2016/11/20/jni"/>
    <updated>2016-11-20T19:32:36+08:00</updated>
    <id>http://www.newtomato.me/blog/2016/11/20/jni</id>
    <content type="html"><![CDATA[<p><img src="http://7xuepc.com1.z0.glb.clouddn.com/2016-11-20-image002.png" alt="image002" /></p>

<p>阅读cocos2dx的代码，我们会发现它里面有很多看似很奇怪的代码，比如<code>cocos2dx/platform/android/jni/</code>下面的c++文件。</p>

<p>里面的函数命名和一般的c++命名不一样！这是因为里面全是JNI规范的函数。</p>

<p>这个JNI是怎么工作的呢？我们先说JAVA是怎么调用c++函数。我们以<code>Cocos2dxLuaJavaBridge.java</code>为例。</p>

<!--more-->

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class=""><span class="line">public class Cocos2dxLuaJavaBridge
</span><span class="line">{
</span><span class="line">    public static native int callLuaFunctionWithString(int luaFunctionId, String value);
</span><span class="line">    public static native int callLuaGlobalFunctionWithString(String luaFunctionName, String value);
</span><span class="line">    public static native int retainLuaFunction(int luaFunctionId);
</span><span class="line">    public static native int releaseLuaFunction(int luaFunctionId);
</span><span class="line">}</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这里面的函数声明前面都有一个native，表示这写函数的定义不在java文件中，而是在native语言中（c/c++中），这样调用这些函数的时候<code>Cocos2dxLuaJavaBridge.callLuaFunctionWithString</code>的时候，就会去JNI中查找对应的c/c++函数。因此在c/c++中就要有这些函数的定义，那就是在<code>org_cocos2dx_lib_Cocos2dxLuaJavaBridge.cpp</code>文件中。每一个函数都有对应的实现。</p>

<p>因此我们在java中调用<code>Cocos2dxLuaJavaBridge.callLuaFunctionWithString</code>实际走的函数是<code>Java_org_cocos2dx_lib_Cocos2dxLuaJavaBridge_callLuaFunctionWithString</code>，java只是一个外表，c++才是里子。</p>

<p>但是这些c++函数怎么和java联系起来了呢？</p>

<p>我们发现java中有如下函数：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class=""><span class="line">static 
</span><span class="line">{
</span><span class="line">    System.loadLibrary("game");
</span><span class="line">}</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>我们的<code>libgame.so</code>文件在编译的过程中已经将<code>org_cocos2dx_lib_Cocos2dxLuaJavaBridge.cpp</code>编译进来了。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
</pre></td><td class="code"><pre><code class=""><span class="line">proj.android/Android.mk
</span><span class="line">
</span><span class="line">LOCAL_SRC_FILES := ../cocos2dx_support/CCLuaEngine.cpp \
</span><span class="line">    ../cocos2dx_support/CCLuaStack.cpp \
</span><span class="line">    ../cocos2dx_support/CCLuaValue.cpp \
</span><span class="line">    ../cocos2dx_support/Cocos2dxLuaLoader.cpp \
</span><span class="line">    ../cocos2dx_support/tolua_fix.c \
</span><span class="line">    ../cocos2dx_support/snapshot.c \
</span><span class="line">    ../cocos2dx_support/platform/android/CCLuaJavaBridge.cpp \
</span><span class="line">    ../cocos2dx_support/platform/android/org_cocos2dx_lib_Cocos2dxLuaJavaBridge.cpp \
</span><span class="line">...</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>因此从java调用c++的时候，按照上面的命名规范，Java_包名_函数名，java的包名是以”.”分开，但是在native语言中”.”的有特殊用途，JNI要求将.全部换成”_“。这样调用java的native函数，java虚拟机就会对应翻译成这样的函数名，找到并调用so文件中的native函数。第一部分完成！</p>

<p>那么c++是如何调用java函数的呢？我们继续往下看。</p>

<p>static函数执行之后，最终在底层一系列函数之后，会调用到一个<code>jni/hellocpp/main.cpp</code>中</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class=""><span class="line">jint JNI_OnLoad(JavaVM *vm, void *reserved)
</span><span class="line">{
</span><span class="line">    JniHelper::setJavaVM(vm);
</span><span class="line">    return JNI_VERSION_1_4;
</span><span class="line">}
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这个函数会将javaVM赋值给JniHelper做为一个成员变量存在。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class=""><span class="line">void JniHelper::setJavaVM(JavaVM *javaVM)
</span><span class="line">{
</span><span class="line">    m_psJavaVM = javaVM;
</span><span class="line">}
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>而有了<code>javaVM</code>之后就可以在c++层面想创建java对象和调用java对象的函数一样的灵活的操作了。获取java是否有某个函数，此处最重要的一个函数就是</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">jint ret = jvm-&gt;GetEnv((void**)&amp;m_env, JNI_VERSION_1_4);</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>此函数获取此时m_env，此变量在我理解是一个JAVA虚拟机的上下文环境。他可以查找java类，对象函数等。有了他我们就以调用java的函数。<br />
例如</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class=""><span class="line">m_classID = m_env-&gt;FindClass(m_className.c_str());
</span><span class="line">m_methodID = m_env-&gt;GetStaticMethodID(m_classID, m_methodName.c_str(), 					m_methodSig.c_str());
</span><span class="line">m_env-&gt;CallStaticVoidMethod(m_classID, m_methodID);</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>m_className就是包名+类名，例如<code>com/company/util/Test</code>,m_methodName就是Test.java里面的静态函数。此处我调用的是静态函数，所以函数声明也必须是static的。</p>

<p>JNI对我们是透明的，很多时候，我们会忽略掉他。但是cocos2dx做的跨平台技术是依赖到他的，资源读取，数据的存储，图片渲染等。还有很多等着我们去发现。有兴趣的同学可以移步<a href="http://wiki.jikexueyuan.com/project/deep-android-v1/jni.html">这里</a>可以学到更多东西。</p>

<p>欢迎大家沟通交流！</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Cocos2dx和OBB的结合使用]]></title>
    <link href="http://www.newtomato.me/blog/2016/11/20/cocos2dxhe-obbde-jie-he-shi-yong"/>
    <updated>2016-11-20T18:04:13+08:00</updated>
    <id>http://www.newtomato.me/blog/2016/11/20/cocos2dxhe-obbde-jie-he-shi-yong</id>
    <content type="html"><![CDATA[<p>上一篇文章我们讲到OBB文件的下载，但是没有说到如何使用。这一篇文章就讲解一下怎么使用。<br />
有两种方法可以使用OBB文件。<br />
<img src="http://7xuepc.com1.z0.glb.clouddn.com/2016-11-20-2311393916-0.jpg" alt="=w300" /></p>

<h3 id="section">方法比较</h3>

<ul>
  <li>第一种方法，obb文件也是一种ZIP文件，我们可以解压缩obb文件，</li>
  <li>第二种方法，直接读取obb文件。<code>getFileDataFromZip</code>这样的方法就可以。</li>
</ul>

<p>这两种方法各有优缺点。<br />
第一种方法将文件解压缩到<code>getWritablePath()</code>文件夹下面。然后此路径<code>addSearchPath</code>到搜索路径中，我们不需要修改其他的代码就可以读取了。缺点是我们需要有一个解压缩的过程。尤其是obb过大的时候，解压缩耗费的时间也会很长。另外解压缩之后，请不要删除obb文件，否则下次进入，又要重新下载。另外这种方式还破坏了obb的加密性。另外这种方法是可行的，但Google并不推荐这种方式。<br />
第二种方式则需要修改部分c++代码。</p>

<p>因此我采用了第二种方法，对CCFileUtil做了一些修改。（主要说一下除了音效音乐之外的使用。）<br />
CCFileUtil是一个基类，在Android平台我们主要关注的是CCFileUtilAndroid.cpp文件。<br />
<!--more--><br />
### 方法梳理</p>

<p>CCFileUtil主要功能是检查一个文件是否存在，能否读取文件的内容。而我们把部分资源文件放到了obb之中，CCFileUtil需要知道这个地方，才能够从那里读取。</p>

<p>在java层，我们知道我们的obb存储的位置是在</p>

<pre><code>	int versionCode = "项目的versionCode"
	String apkName = Helpers.getExpansionAPKFileName(sContext,true,versionCode);
	return Helpers.generateSaveFileName(sContext,apkName);
</code></pre>

<p>通过JNI，将这个路径${obbPath}传递给c++，可以参考<code>CCFileAndroid.cpp</code>里面的<code>getApkPath()</code>函数。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">std::string resourcePath = getApkPath();
</span><span class="line">s_pZipFile = new ZipFile(resourcePath, "assets/");        </span></code></pre></td></tr></table></div></figure></notextile></div>
<p>类似s_pZipFile，我们也生成一个${obbZipFile}，用于文件的查找。</p>

<p>然后将此路径<code>addSearchPath</code>到搜索路径中。通过阅读CCFileUtil.cpp文件我们得知检查一个文件的全路径主要是检测<code>isFileExist</code>函数。如果他证明存在此文件，就能获取到全路径。</p>

<pre><code>fullPathForFilename--&gt;getPathForFilename--&gt;getFullPathForDirectoryAndFilename--&gt;isFileExist
</code></pre>

<p>因此我们修改isFileExist文件，在里面根据文件的路径检查是否在。伪代码如下：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
</pre></td><td class="code"><pre><code class=""><span class="line">bool CCFileUtilsAndroid::isFileExist(const std::string&amp; strFilePath)
</span><span class="line">{
</span><span class="line">	...
</span><span class="line">    bool bFound = false;
</span><span class="line">
</span><span class="line">    if (strFilePath.find(${obbPath}) != std::string::npos)
</span><span class="line">    {
</span><span class="line">        if (${obbZipFile} &amp;&amp; ${obbZipFile}-&gt;fileExists(strPath))
</span><span class="line">        {
</span><span class="line">            bFound = true;
</span><span class="line">        } 
</span><span class="line">    }
</span><span class="line">	...
</span><span class="line">}</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>上面我们把obb文件做成了ZipFile对象，因此在doGetFileData中，就很容易得到文件的内容。伪代码如下：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
</pre></td><td class="code"><pre><code class=""><span class="line">unsigned char* CCFileUtilsAndroid::doGetFileData(const char* pszFileName, const char* pszMode, unsigned long * pSize, bool forAsync)
</span><span class="line">{
</span><span class="line">    unsigned char * pData = 0;
</span><span class="line">    
</span><span class="line">...
</span><span class="line">    string fullPath = fullPathForFilename(pszFileName);
</span><span class="line">   
</span><span class="line">    // 获取obb文件
</span><span class="line">    if (${obbZipFile} &amp;&amp; fullPath.find(${obbPath}) != std::string::npos){
</span><span class="line">        
</span><span class="line">        if (forAsync)
</span><span class="line">        {
</span><span class="line">            pData = ${obbZipFile}-&gt;getFileData(fullPath.c_str(), pSize, ${obbZipFile}-&gt;_dataThread);
</span><span class="line">        }
</span><span class="line">        else
</span><span class="line">        {
</span><span class="line">            pData = ${obbZipFile}-&gt;getFileData(fullPath.c_str(), pSize);
</span><span class="line">        }
</span><span class="line">    }
</span><span class="line">    ...
</span><span class="line">  }
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="section-1">总结语</h3>

<p>至此我们就能够读取obb里面的内容了。<br />
我的方法基于将obb看成了ZIP，模仿apk的方式去读取文件。将obb位置放到了搜索路径。ZIP对象存在且能够从里面读取文件，则表明文件存在。就可以读取他了。</p>

<p>这里面设计到JNI传递数据。其实这对于我们只要仿照APK路径传递就可以了。关于JNI具体的实现，还请看下一章节内容。</p>

<p>感谢你的阅读！</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Google Android 扩展文件OBB的使用]]></title>
    <link href="http://www.newtomato.me/blog/2016/11/20/google-android-kuo-zhan-wen-jian-obbde-shi-yong"/>
    <updated>2016-11-20T16:13:41+08:00</updated>
    <id>http://www.newtomato.me/blog/2016/11/20/google-android-kuo-zhan-wen-jian-obbde-shi-yong</id>
    <content type="html"><![CDATA[<p><img src="http://7xuepc.com1.z0.glb.clouddn.com/2016-11-20-IMG_06702.jpg" alt="" /></p>

<p>我们提交应用到Google Store的时候，Google要求应用的大小不能够超过100M，那么超过100M怎么办呢？<br />
那就用到了本章将要讲的东西<strong>OBB</strong>（扩展二进制文件）。</p>

<p>OBB文件，你可以看成是一个ZIP文件。我们提交母包APK的时候，在界面上也有提价扩展文件的地方。假设我们的母包APK是100M，OBB扩展是100M，用户在Google Store上看到或者下载的大小将是二者之和。<br />
<!--more--><br />
因此一个完整的流程是下载应用，是同时下载母包和OBB，但是Google文档中提到，他们并不保证OBB文件能够100%下载完成。这就需要我们在启动应用之后，程序去检测是否已经正确下载和验证有效性，如果是则可以进入游戏了。如果不是，那么就要重新下载OBB。</p>

<p>为什么要验证OBB的有效性呢？难道下载100%不行么？这是因为OBB安装的位置是暴露给用户的。用户可以打开修改这个文件。因此制作的时候要注意做好加密工作。</p>

<p>Google提供的jobb工具刚好有加密的参数，其参数的使用方法可以参考<a href="https://developer.android.com/studio/command-line/jobb.html">这里</a></p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">$ jobb -d /temp/assets/ -o my-app-assets.obb -k secret-key -pn com.my.app.package -pv 11</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>上面提到OBB是暴露给用户的，那么OBB具体是存放在哪里呢？<br />
在Google文档中提到是在</p>

<p><code>&lt;shared-storage&gt;/Android/obb/&lt;package-name&gt;/&lt;obb-name&gt;.obb</code></p>

<ul>
  <li>shared-storage 是通过<code>getExternalStorageDirectory()</code>获取的位置</li>
  <li>package-name是我们的包名，通过函数<code>getPackageName()</code>获得.</li>
  <li>obb-name则是有自己的命名规范。<code>[main|patch].&lt;expansion-version&gt;.&lt;package-name&gt;.obb</code></li>
  <li>因为Google能够让我们提交的obb只有两种类型，main和patch。main表示主要的obb包，patch是更新包的意思，例如我们经常更新的部分，可以做成patch，这样下次更新APP的时候，只要提交着一个patch就行了。</li>
  <li>expansion-version表示版本号，他们我们的AndroidManifest.xml里面的versionCode是一致的。</li>
  <li>pack-name和上面的解释一致。</li>
  <li>针对 Android 2.3 及以上版本的 APK，母包要求在100M以内，如果是 Android 2.2 及以下版本则要求在50M以内。</li>
</ul>

<h3 id="section">开始代码</h3>
<p>首先需要加入三个依赖库。<br />
1. <a href="https://developer.android.com/google/play/expansion-files.html#ZipLib">APK Expansion Zip Library</a><br />
2. <a href="https://developer.android.com/google/play/licensing/index.html">Application Licensing</a><br />
3. <a href="https://developer.android.com/google/play/expansion-files.html#AboutLibraries">Downloader Library</a></p>

<p>另外，Google的licensing在lollipop会有如下的报错：<br />
&gt;java.lang.IllegalArgumentException: Service Intent must be explicit: Intent { act=com.android.vending.licensing.ILicensingService }</p>

<p>解决方法：<a href="http://stackoverflow.com/questions/28305125/android-app-crashes-on-lollipop">http://stackoverflow.com/questions/28305125/android-app-crashes-on-lollipop</a></p>

<p>这三个库在<code>android-sdk文件夹/extras/google/</code>下面都有。只要导入到Eclipse或者Android Studio即可！<br />
导入之后会有部分报错情况，可以检查他们之间彼此依赖关系，清理在重新build即可。</p>

<p>接下来按照Google文档我们要集成DownloadService和BroadcastReceiver等，这一部分代码我们可以直接参考Google的实例工程<code>downloader_sample</code>，他的位置在<code>android-sdk文件夹/extras/google/market_apk_expansion/downloader_sample</code>。我们要做的就是修改如下两个函数</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class=""><span class="line">public static final String BASE64_PUBLIC_KEY = "YourLVLKey";
</span><span class="line">// You should also modify this salt
</span><span class="line">public static final byte[] SALT = new byte[] { 1, 42, -12, -1, 54, 98,
</span><span class="line">   -100, -12, 43, 2, -8, -4, 9, 5, -106, -107, -33, 45, -1, 84
</span><span class="line">};</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>BASE64_PUBLIC_KEY是我们创建Google应用的时候，会自动生成的key，SALT则是需要我们修改一下即可使用。</p>

<p>现在我们使用downloader_sample的包名和version生成一个obb文件和apk文件，然后提交。等待生效之后，我们要开始测试。</p>

<h3 id="section-1">如何测试</h3>

<p>按照上面的方法我们做好obb提及到Google开发者平台后，等待beta版本生效之后，就可以在本地测试了。<br />
复杂的测试方法是，需要我们登录Google Play Store找到beta应用下载测试（前提条件使我们要加入测试组，才能看到这个应用）。</p>

<p>相对简单的方法如下:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">adb push xxx.obb /Android/obb/${package-name}/
</span><span class="line">adb install xxx.apk</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>启动我们的应用，检测是obb已经下载，验证obb有效性。downloader_sample的启动界面会提示我们此时已经Success完成。</p>

<p>这两种方式都可以使用，也不必每次都重新提交到Google那里了。此时就可以连着设备直接debug调试了。</p>

<h3 id="section-2">结束语</h3>

<p>走通这个流程中，我们遇到了不少奇怪的问题，比如Google无法验证身份，（检查是否加入了测试组，设备上的Google账号是否正确等，缓存是否清理），比如没有检测到obb文件，（网络是否正常，能否连接到Google play Store等），文件的下载之后大小有问题等。因此建议你们，手里要有一个可以翻墙的VPN才是事半功倍的利器啊。</p>

<p>至此OBB的工作已经完成，站在Google巨人的肩膀上，省去了我们不少力气。下篇文章，我将结合cocos2dx来讲一下怎么使用下载下来的obb文件。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[万圣节上线纪念]]></title>
    <link href="http://www.newtomato.me/blog/2016/11/01/mo-sheng-jie-shang-xian-ji-nian"/>
    <updated>2016-11-01T18:23:34+08:00</updated>
    <id>http://www.newtomato.me/blog/2016/11/01/mo-sheng-jie-shang-xian-ji-nian</id>
    <content type="html"><![CDATA[<p><img src="http://7xuepc.com1.z0.glb.clouddn.com/2016-11-01-1348470031_5209.jpg" alt="1348470031_5209-w395" /></p>

<p>从去年万圣节开始，我们开始了第一个正式的大更新，到今天已经整整一年。<br />
正因为此次的紧张仓促的更新，我才发现了我们自身很多问题。这些问题由来已久，就像是我们的老朋友一样自然到我们总是忽视了他，直到他们全部暴露出来，压得我们无法喘息。</p>

<p>小团队就是如此无奈，顾得了这边，顾不了那边，想要靠着流程上来保证每次更新能保质保量。但实际上本质上还是需要靠人。负责任有态度的人。即使是大的公司，螺丝钉螺丝帽如果不靠谱带来的问题也是严重的。而流程能够明确职责。让彼此轻松一些。<br />
<!--more--></p>

<p>先对于实际问题，我们还是得实际分析。站在空中楼阁谈问题全是耍流氓。</p>

<ol>
  <li>没有顺手的调试工具，纯靠着打印这种古老的方式寻找问题。浪费时间。</li>
  <li>项目资源管理混乱，现在给我们带来很多问题。</li>
  <li>沟通不畅，重复做了大量工作。</li>
  <li>开发团队每个人承担的工作较多，无暇顾及其他。因此减少了code review。</li>
  <li>需求变化，代码不够灵活，每次都需要跟着修改。增加了工作量。</li>
  <li>deadline目标明确，但是小目标没有，进度没有人负责跟踪，任务经常压倒deadline之前几天做。已成为拖延症晚期患者。</li>
  <li>开发部门承担过多的东西，包括对每个资源的命名和位置管理。此处完全可以交给美术部门来做。</li>
  <li>需求来源不统一，有的是看邮件，有的时候看jira，有的时候来自某个人的转达。转达的不清楚，不知道做什么，具体什么需求？</li>
  <li>人手不足是常态了，在穿插着需求的时候，即使有git这样的神器也无法改变我们的痛苦。</li>
  <li>对自动化依赖不足，明明可以解放一个dev人力，却一直没有想着解决。有一种习以为常的痛苦。</li>
  <li>测试力量不足，非常不足。因此要求我们在开发过程中就要做的更好，测试的更充分才可以。</li>
</ol>

<p>问题年年有，今年特别多。一个问题一个问题的冒上来。有些能够解决，有些则无法解决，只能靠其他问题来解决了。</p>

<p>能暴露出来，最好，至少我们有机会去发现他们。而不是被麻木的等待被它解决掉！所以接下来我准备先从我们自己做起，改善我们自己开发工具，将发布脚本做成自动化，将资源整理一下，和美术部分沟通清楚，以后他们来负责做这一块儿。</p>

<p>其他问题和团队分享一下，众人一起讨论一下，看能否优化。小团队效率就是生命，彼此依赖才能走的下去。<br />
从自身做起，影响他人，才是小团队需要的人才。</p>

<p>写在后面的话：</p>

<pre><code>在一年紧张快速上线的节奏下，时间过的就特别快。
马上就要2017了，我感到紧张。什么都没有准备好。
以往喜欢争，喜欢把话爽快地全说出来，哪怕对方很不舒服。
现在我学会了憋住话，这很难受，但是需要这么做，
争论无可避免的会争吵，争吵又带来消极，影响团队。
每个人的出发点都不一样，为了什么走在一起呢？
我期初以为大家都是为了证明自己的能力。现在觉得只是为了利益。
承认这一点，是看清自己的第一步。
不知道什么时候，激情梦想已经从我们眼中褪去。反而是这些东西能留住我们。
古人说，天下熙熙皆为利来，天下攘攘皆为利往。真是诚不欺我也！
长期和计算机打交道，会觉得技术是很厉害的。
每天都有新的框架发布，每天都有新的技术更新，每年都有新的趋势。
时时刻刻都要自己能够跟得上新的潮流。
看着年轻的90后，在看看自己，真实的感到实实在在的压力。
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[支付宝微信接入]]></title>
    <link href="http://www.newtomato.me/blog/2016/10/23/zhi-fu-bao-wei-xin-jie-ru"/>
    <updated>2016-10-23T14:28:52+08:00</updated>
    <id>http://www.newtomato.me/blog/2016/10/23/zhi-fu-bao-wei-xin-jie-ru</id>
    <content type="html"><![CDATA[<p>一般情况下，想要在国内上Android平台，比如百度，360，小米等，都需要接入他们自己的SDK，里面集成了不少第三方的支付。所以只需要一次接入，就能搞定所有的支付接口，确实方便的很。（同时也有不少负面问题，接触就知道了）。但是一些小众平台，并不会提供这样的SDK，所以需要我们自己接入。PS：注意小众并不意味着市场小，反而他们提供的AUP值和留存率非常高。</p>

<!--more-->

<h3 id="section">开始动手 - 接入微信</h3>

<p>首先，需要注册一个<a href="https://open.weixin.qq.com/">微信开发者账号</a>，按照文档搭建一个应用，然后按照demo接入就可以了。但是在这中间有几个问题一定要注意。</p>

<ol>
  <li>开发者需要需要提交一些资料，申请认证的资质。这样才能够申请到支付服务。我们一开始想的简单了以为可以先尝试接入，然后上线在申请资质。结果发现不行。<strong>这一步走不通，下面即使跑通了他们的demo，也无法在自己的项目中运行。</strong></li>
  <li>
    <p>创建应用填写项目的包名和<strong>签名</strong>，此处的签名慎重，我们在这个地方也是吃过苦头。<br />
一般android的签名，想到的就是我们项目中使用<code>keytool</code>，<code>jarsigner</code>的方式给项目签名，但是这里不是的。<br />
这里的签名是微信自己的协议，我们将项目apk安装到自己的手机，然后在安装一个<a href="https://res.wx.qq.com/open/zh_CN/htmledition/res/dev/download/sdk/Gen_Signature_Android1f09c7.apk">微信的签名apk工具</a>，其中这个签名工具，输入自己应用的包名，即可生成一个32位签名。这个就是微信需要的签名。但是注意，我们平时coding的时候，一般是开发模式，debug模式，所以打包生成的apk有可能也是Debug模式，一旦换成Release模式，生成出来的这个签名又会不一样。<br />
因为为了保证Debug和Release模式签名一致。我们唯一要做的就是设置项目两种模式下面keystore是一样的。我们使用的是Android Studio，因此只要按照如下设置即可。<br />
<img src="http://7xuepc.com1.z0.glb.clouddn.com/2016-10-23-release.jpeg" alt="release" /><br />
<img src="http://7xuepc.com1.z0.glb.clouddn.com/2016-10-23-debug.jpeg" alt="debug" /><br />
这样生成出来的签名前后都是一致的。</p>
  </li>
  <li>
    <p>签名搞定之后按照他们的Demo修改我们的项目，还要注意一点的就是在支付完成之后的会调回到项目中，进入<code>WXPayEntryActivity</code>,这个我们可以完全拿过来放到自己的Project中，但是一定要注意保持他的目录结构。在AndroidManifest.xml中是如下的表示：<br />
  <code>&lt;activity android:name=".wxapi.WXPayEntryActivity" android:exported="true" 	andorid:launchMode="singleTop"&gt;
 &lt;/activity&gt;</code></p>
  </li>
  <li>测试的时候会遇到这样的情况，Demo也会遇到这种情况。就是第一次点击支付，弹出了微信的支付界面。但是第二次点击，就不会成功。然后删应用在安装，重复同样的错误。有些蒙圈不知所谓。最后Google了一大圈，才找到一个方法，<strong>删除微信的缓存</strong>。然后问题你就解决了。再也没有出现过。可能是运气好，看到别人即使用了这样的方法还是会出现问题。</li>
  <li>玩家支付的时候，要检测是否安装了微信，否则支付失败。</li>
  <li>问题各不相同，只要看准几条，你一定能解决他。包名，签名，应用名（微信回调的scheme）。</li>
</ol>

<h3 id="section-1">开始动手 - 接入支付宝</h3>

<p>相对于微信的一个模棱两可的签名概念，支付宝的公钥私钥就简单的多了。<br />
同样，这里也需要先申请一个开发者账号，和签约支付。<br />
需要的注意的问题有如下几点：<br />
1. 提交公钥。支付宝对用户的金钱往来是非常注意的。使用这种非对称式加密的方法。对用户的请求进行加密。防止被别人篡改数据。所以按照他的<a href="https://cshall.alipay.com/enterprise/knowledgeDetail.htm?knowledgeId=201602033418">文档</a>去生成公钥私钥就行。但是生成完了，得验证是否正确。在提交公钥的弹出框下面有个验证公钥链接，点进入后，将要我们用私钥生成的一个段密文粘贴进来验证。验证通过即证明我们的公钥私钥没问题。<br />
2. 私钥加密这种一定放到后端去做。他的客户端里面的代码只是给我们看流程使用的。</p>

<p>上述是我们遇到的问题，在已经有了开发者资者的情况下，总体花费了2天时间接入，比较顺利。希望遇到问题的你，不要着急，不要慌。好事多磨，多看文档和FAQ，总会解决的。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[搭建ipv6环境和问题记录]]></title>
    <link href="http://www.newtomato.me/blog/2016/09/18/da-jian-ipv6huan-jing-he-wen-ti-ji-lu"/>
    <updated>2016-09-18T20:15:26+08:00</updated>
    <id>http://www.newtomato.me/blog/2016/09/18/da-jian-ipv6huan-jing-he-wen-ti-ji-lu</id>
    <content type="html"><![CDATA[<p><img src="http://7xuepc.com1.z0.glb.clouddn.com/2016-09-18-14742018443262.png" alt="" /><br />
自从16年6月份开始，苹果要求提交的应用一定要支持ipv6。ipv6是做什么用呢？和ipv4有什么区别？<br />
其实这个教科书上已经和我们解释过了，只是这一天来得太快。<br />
ipv4的是32位长度，而ipv6是128位，是ipv4的4倍。能够大大的解决ip地址不够用的问题。<br />
ipv4能用提供2^32 - 1,ipv6则能够提供2^128 - 1的地址。<br />
所以苹果在这个地方加入这个限制条件，就是为了推广ipv6的使用。</p>

<p>而对于我们开发者要做的事情，就是搭建一个ipv6的网络地址。<br />
同时将我们项目中那些用ipv4的网络框架改为支持两种协议。</p>

<p>我分享这篇文章主要介绍怎么搭建一个ipv6的网络。我们在这个地方摔进了个大深坑。<br />
<!--more--><br />
有两种方式可以大家ipv6的网络，一种是使用网线的方法，一种是使用手机4G移动网络。</p>

<p>这两种方法都是相似的原理，都需要用到DNS64/NAT64的转发。那么原理是什么呢？看下面的这一张图片<br />
<img src="http://7xuepc.com1.z0.glb.clouddn.com/2016-09-18-1458809-25687ab1e24f61ec.jpg" alt="1458809-25687ab1e24f61e" /></p>

<p>首先要知道的是，发出任何一个请求，最终都会映射成一个地址对地址的请求。所以域名需要转换成IP，这一层是域名解析服务器做的。他很快的将查询的地址发给请求方，请求方在把地址和请求信息封装成信息报，以TCP/IP的协议发出去。</p>

<p>上图中，Client就是手机设备，在我们搭建的ipv6环境中，请求先送到DNS64 Server，为啥呢？因为你搭建的是DNS64/NAT64网络。也就是说你的电脑此时也是一个域名解析服务器。他会去请求DNS服务器，服务器如果存在ipv6地址，就立即返回这个地址，然后ipv6转给DNS64 Server，然后在传给Client。如果DNS Server没有配置这个ipv6，则返回一个ipv4地址。转给DNS64 Server之后，他会将ipv4转换一个下，做成ipv6的样子，转给Client，Client拿到这个组装之后的地址在向外发请求。贴一个更详细的图<img src="http://7xuepc.com1.z0.glb.clouddn.com/2016-09-18-14742011971107.jpg" alt="" /></p>

<p>所以我们搭建的这个环境就是一个中转站，将我们的ip地址做一下转换。</p>

<p>原理既然如此，接下来说一下怎么搭建这个ipv6的环境。</p>

<h3 id="ipv6">使用网线搭建ipv6网络</h3>

<p>找一台MAC电脑，能够使用网线，然后拨号上网，System Preferences -&gt; Sharing (点击此处需要按住option键)，然后在弹出界面上勾选[x]Create NAT64 Network,将我们的有线网络通过Wifi的形式共享出去。在Wifi Option按钮可以不设置密码。<br />
<img src="http://7xuepc.com1.z0.glb.clouddn.com/2016-09-18-14741972537636.jpg" alt="" /></p>

<p>然后点击左侧的<strong>互联网共享</strong>。此时弹框，点击<strong>启动</strong>即可。</p>

<p>然后手机连接你搭建的这个网络，在手机的网络设置里面检查IP对应的DNS是否是ipv6格式的ip地址，以冒号分割。<br />
走到这一步还是未必成功，那么可以看第二套方案</p>

<h3 id="gipv6">使用4G网络搭建ipv6的环境</h3>

<p>首先手机要关闭Wifi，连接4G。然后用数据线连接MAC电脑，使用USB的形势共享网络。<br />
接下来就是在电脑的系统设置里面，按住option键共享网络，步骤和上面一样。将iPhone USB网络以wifi的<br />
形式共享出去。然后再找一台iPhone手机，连接这个共享的网络。<br />
在网络连接里面检查是否是ipv6的地址格式。</p>

<h3 id="section">遇到的问题</h3>

<ol>
  <li>这两种方式，我们使用第二种成功，而第一种却没有成功。MAC电脑使用的是MAC Mini，版本是10.11.6。还没有找到根本原因。</li>
  <li>提交版本审核的时候，被拒。理论上服务器是可以不需要支持ipv6的，但是查到的资料均指向一定要服务器配置这个呢？暂时我的猜测是，DNS64继续ipv6不成功，在请求ipv4，这期间花费了时间超时导致请求不能进入。所以为了能够快速进入最好还是让服务器也支持一下。</li>
  <li>怎么检查自己的服务器是否支持ipv6呢，easy 方法就是在<a href="http://ipv6-test.com/validate.php">ipv6 test</a>里面输入域名，然后就知道了。百度有一个ipv6的域名，ipv6.baidu.com 。大家可以测试看看他的4A就配置了ipv6的地址。<img src="http://7xuepc.com1.z0.glb.clouddn.com/2016-09-18-14741996623390.jpg" alt="" /></li>
  <li>自己的服务器怎么配置ipv6的地址呢？只要在自己的域名解析服务商那里设置一个aaaa即可。可是如何获得ipv6呢？目前只有国内的高校网才有NAT64 + NDS64的服务如下图：<img src="http://7xuepc.com1.z0.glb.clouddn.com/2016-09-18-14742001654945.jpg" alt="" /><br />
 具体获得ipv6的方法，可以参考这个链接。里面提供了收费和免费两种方法。<a href="http://www.solve6.com/">ipv6 解决方案</a>。</li>
</ol>

<p>到此我们的问题算是解决了，如果你还是遇到更加奇怪的审核没有通过的问题。建议你<a href="https://github.com/wg689/Solve-App-Store-Review-Problem">移步至此</a>，希望能够帮得到你了。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[快速打包测试提交苹果审核的流程]]></title>
    <link href="http://www.newtomato.me/blog/2016/09/18/kuai-su-da-bao-ce-shi-ti-jiao-ping-guo-shen-he-de-liu-cheng"/>
    <updated>2016-09-18T17:22:24+08:00</updated>
    <id>http://www.newtomato.me/blog/2016/09/18/kuai-su-da-bao-ce-shi-ti-jiao-ping-guo-shen-he-de-liu-cheng</id>
    <content type="html"><![CDATA[<blockquote>
  <p>天下武功，唯快不破。加快时间是制胜王道。</p>
</blockquote>

<p><img src="http://7xuepc.com1.z0.glb.clouddn.com/2016-09-18-1.jpg" alt="1" /></p>

<p>对于出一次大包，是一件很费时费力的事情。具体包括以下步骤：</p>

<ol>
  <li>加密资源。正常情况下，每个团队对自己做的项目都有这样的要求，而加密可以借助于工具或者使用脚本。一般是10~20分钟。项目大小不同，小的项目会很快，大的项目则慢的多。</li>
  <li>打包ipa或者apk文件。此时依赖于项目的复杂度，有依赖的项目库也会重新build，不修改依赖库，也就是使用缓存的build文件会加快速度。一般需要30分钟左右。</li>
  <li>上传ipa或者apk文件。这个过程依赖网络速度。我们网络上传速度是100~200k/s的速度，一般需要20分钟左右。<br />
<!--more--></li>
  <li>苹果提交到iTunes Connect，android提交到Google Developer Console后台。等待审核生效。打开测试通道。此时时间不固定，苹果审核时快时慢，我们最快半小时就可以进入内测，最慢经过了3个小时，Google会快一些。</li>
  <li>进入内测阶段，苹果通过TestFlight开始下载。但是下载真的慢的要死哦。Google的内测则快一些。只要VPN给力即可了。</li>
</ol>

<p>以上差不多是提交大包需要经历的过程。走完一套下来，大约需要2~3个小时。</p>

<p>但是这个速度非常令人头疼，提交的速度越快，问题越能提早发现。能加快时间，自然对我们是极好的。所以在上述基础上我们分析了一下，可以从以下几个方法去做优化。</p>

<p>第一步和第二步是无法节省时间的。我们在一台mac电脑搭建的服务器上运行<code>jenkins</code>,已经将人力解放出来。<br />
第三部提交和第四部审核是可以考虑别的方法。由于苹果初步审核比较慢，所以我们想到的方法就是打两个包，一个是<strong>adhoc</strong>证书，一个是<strong>app store</strong>证书。adhoc证书的ipa包提交到别的<strong>分发服务的提供商</strong>上面，及早进入内测阶段。内测的同学测试没有问题了之后，然后在将app store证书的版本提交到iTunes Connect上面。只是切换了证书，代码和资源没有做任何修改。分发服务的提供商做的事情其实和TestFlight一样。但是他们有其他优势：</p>

<ol>
  <li>服务器在国内，提交和下载的速度非常快。</li>
  <li>没有初审状态。这个苹果有，不知道他们在审核什么。一般都是在正式提交才开始漫长的审核。</li>
</ol>

<p>至于这种类似TestFlight的第三方分发服务提供商，国内知名的有</p>

<ol>
  <li><a href="http://pre.im/">pre.im</a></li>
  <li><a href="http://tako.im/">tako.im</a></li>
  <li><a href="https://www.pgyer.com/">蒲公英</a></li>
  <li><a href="http://fir.im/">fir.im</a></li>
</ol>

<p>蒲公英用的比较多，现在比较知名的是fir.im，我们现在使用的也是它。</p>

<p>所以优势很明显了，能为我们省去不少等待时间。这样下来之后，我们<strong>时间缩减到30分钟~1小时</strong>。简直要欢呼雀跃了。</p>

<p>可能有更好的提交的方法，还请知道的老司机同学帮帮忙，给我们提点好的意见，感激不尽！</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Stack Pack制作]]></title>
    <link href="http://www.newtomato.me/blog/2016/09/17/stack-packzhi-zuo"/>
    <updated>2016-09-17T21:49:19+08:00</updated>
    <id>http://www.newtomato.me/blog/2016/09/17/stack-packzhi-zuo</id>
    <content type="html"><![CDATA[<h3 id="section">创建方法</h3>

<p>IOS 9 自上周发布以来，开始支持一种类似微信的表情包功能，对于怎么打包苹果官方网站有详细的介绍，这里我们也稍微介绍一下，并且列举一些我们项目中遇到问题。</p>

<p>首先，iMessage app分为两种类型，一种是纯图片资源，不需要编写代码，称之为sticker pack，另外一种可以编写代码，调用一些类似支付的接口的API，称之为iMessage app，他们都可以作为应用的扩展，也可以独立成为一个应用。因此有两种不同的创建方式。如下图所示：<br />
<!--more--><br />
<img src="http://7xuepc.com1.z0.glb.clouddn.com/2016-09-17-a.jpeg" alt="创建应用" /></p>

<p><img src="http://7xuepc.com1.z0.glb.clouddn.com/2016-09-17-b.jpeg" alt="创建应用扩展" /></p>

<h3 id="sticker-pack">Sticker pack</h3>

<p>Sticker pack的制作很简单，准备好一些图片（png,jpg,gif），大小在500k之内即可。将资源直接拖拽到stacker packer的xcassets里面。在右侧属性栏可以调节大，中，小三种显示模式。<br />
然后xcode选择最新的ios10的模拟器，运行。<br />
在模拟器的iMessage中测试互发消息即可看见我们的表情包了。</p>

<p>现在一个简单的表情应用算是搞定了，如果你有开发者账号，可以直接提交给苹果审核了。</p>

<p>而我们遇到了另一个问题，就是需要和应用挂钩，也就是表情包需要成为我们应用的扩展，这样应用在被用户安装到设备上的时候，表情包自然而然的就会出现在用户的iMessage里面。因此，我们用图二扩展的形式在应用下面创建表情包。</p>

<p><img src="http://7xuepc.com1.z0.glb.clouddn.com/2016-09-17-c.jpeg" alt="" /></p>

<p>此时他下面出现一个Info.plist的文件，他也需要一个唯一id的，而且这个id是有强制规则的，<strong>以container app的id为前缀，后面再增加自己的名字。前缀一定要和container app的id保持一致</strong>。</p>

<p>然后模拟器和真机运行测试。<br />
<img src="http://7xuepc.com1.z0.glb.clouddn.com/2016-09-17-IMG_0585.png" alt="IMG_0585" /></p>

<p>在苹果未正式发布ios10的时候，真机需要安装ios10的GM版，需要到苹果官方网站下载一个文件（<code>iOS_10_beta_Configuration_Profile.mobileconfig</code>）,这是一个OTA证书，安装了之后即可以更新最新的ios10开发版。不过现在已经用不到了。</p>

<p><strong>iMessage App</strong>需要有一些Swift的基础，大家有需要可以移步至此<a href="http://www.jianshu.com/p/be79b8729bf8">趁热来一波，WWDC 2016 iMessage App开发</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python基本使用]]></title>
    <link href="http://www.newtomato.me/blog/2016/09/11/pythonji-ben-shi-yong"/>
    <updated>2016-09-11T19:15:05+08:00</updated>
    <id>http://www.newtomato.me/blog/2016/09/11/pythonji-ben-shi-yong</id>
    <content type="html"><![CDATA[<p><strong>Python</strong>是一门很容易掌握的语言，简单的语法强大的功能，在很多地方都视他为最高效的语言，尤其是在处理数据和文本上面，真的是帮了我们大忙。比如讲产品经理那里过来的文案导出成localizaiton文件，或者将他们的Excel表格导出成json，xml等配置文件，再将我们的数据信息导成他们看的懂得excel表格。<br />
如下的部分是我在团队内部（针对有部分编程语言基础的同学）做的关于Python的分享，也算是对自己使用Python做一个总结吧。</p>

<!--more-->
<p><strong>首先，如何安装Python。</strong><br />
MAC的同学，直接在命令行中敲入<code>python --version</code>，输出版本号就好了。如果没有请安装<code>brew install python</code>，或者到Python的官网按照平台去下载即可。<br />
Window的安装，和上面相似，如果没有安装也请到官网上下载。<br />
<strong>其次，基本的语法。</strong><br />
Python是动态语言，因此他和java已经c语言等静态语言最大的不一样的地方就是，他的一切皆可以不需要先定义类型。例如<br />
在java中，变量的声明是<code>String name= ""</code>,但是在python中属性可以不用声明类型。在使用的时候，赋值是什么类型，变量就是什么类型。<br />
同时函数也有这种特性，java中对象实例化之后，以class为准，class有什么函数，对象就会有，对象不能增加函数，但是python可以，a1,a2均是实例化A，但是a1对象，可以在运行时自己给自己增加一个函数。a2不受影响，并没有这个函数。<br />
所以，秉着这个基本原则，来看Python的语法就简单多了。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class=""><span class="line">a = 123
</span><span class="line">b = "hello,world"
</span><span class="line">def func():
</span><span class="line">	pass</span></code></pre></td></tr></table></div></figure></notextile></div>

<p><strong>第三，常用的Python的基本数据结构</strong></p>

<h2 id="string">String字符串</h2>
<p>在Python中<code>‘’</code>和<code>“”</code>都表示是str类型。不做区分。他最长用的函数：拼接，替换，查找，格式化输出，切片还有令人头疼的中文编码<br />
	拼接字符串，使用的是<code>+</code>，<code>"你好啊，" + b + "世界！"</code>，这样虽然达到效果然后，不够美观和易读，所以用到了格式化，<code>"你好哇，%s世界"</code>，这和其他语言一样，%s表示字符串，%d表示数值，%02d表示保留两位，不足两位用0补齐。<br />
	查找和替换，最常用的还是和正则表达式一起使用。<br />
	比如<code>msg = "你要花费%{itemName}和%{itemName2}来做这件事情么？"</code>，这里面我们要做的是讲%{itmName}和%{itemCount}替换成空白字符。那么怎么做好呢？<br />
	简单的方法就是</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">msg = msg.repleace("%{itemName}","")
</span><span class="line">msg = msg.repleace("%{itemName2}","")</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>还有一种更好的方法，那就是使用正则表达式，表达式匹配<code>%{}</code>里面的任何字符，这样更加灵活。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">import re #导入包
</span><span class="line">msg = re.sub(r'%{.+}','',msg)</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>接下来说说，中文编码的问题。<br />
中文编码之所以出问题，是因为Python的默认编码是Ascii码，所以输出中文便有问题。我们需要将中文编码成Unicode输出。有的情况下，我们在py文件中增加中文注释，下次再打开文件，文件已成乱码，这是为何呢？原因就是操作系统在我们写注释的时候，是以utf的编码展示中文的，但是存成了文件之后，文件的编码就以utf8的格式存储，再次打开的时候，py文件就以默认的Ascii码读取文件，自然就是乱码了。因此为了避免这种问题，我们在py文件的开头增加<code># -*- coding:utf-8 -*-</code>就可以解决这个问题，这是告诉系统以utf-8的格式打开这个文件。<br />
因为知道了这个问题，我们在读取中文的时候，尽量告诉系统我们要的编码方式，比如从文件中读取内容。讲内容读进来之后，直接用utf-8解码。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class=""><span class="line">f = file.open(fileName,"r")
</span><span class="line">content = f.read()
</span><span class="line">content.decode("utf-8")</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>另一种情况是：我们print打印出来的中文是正常的，但是写入到文件中，就会报错。<br />
例如：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class=""><span class="line">s = u"我是中文"
</span><span class="line">f = file.open("test.txt","w")
</span><span class="line">f.write(s)
</span><span class="line">f.close()</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这种情况报错是因为s此时的类型是unicode，而f.write(s)参数要求是str类型，因此从unicode到str类型有一层转换，此时没有指定编码，py会默认使用Ascii，自然就报错了，因此我们需要在写入前，手动做一次转换就好了</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">s = s.encode("utf-8")</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>通过<code>type(s)</code>的方法我们得知此时<code>s</code>就是<code>str</code>类型了。<br />
此处是py2才会有的编码问题，在py3已经不再这么麻烦了。如果我们继续使用py2，推荐大家使用codecs模块。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">with codecs.open('test.txt', 'w', encoding='utf-8') as f:
</span><span class="line">   f.write(s)</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="listdict">list，dict数据类型使用</h2>

<p>这两种类型相信很多同学都很熟悉，list类似数组，dict就是字典。<br />
常用的方法，添加，删除，查找，切片。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class=""><span class="line">list.append(value)
</span><span class="line">dict["key"] = value
</span><span class="line">list.remove(value) #如果value不存在会报错
</span><span class="line">del dict["key"]  
</span><span class="line">print(dict[key]) #如果key不存在会报错，在访问前，建议用dict.get(key)来做检查。
</span><span class="line">print(list[:3])</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>还有常用的生成列表的方法</p>

<p>range(1,N) #生成1，N自然数列表<br />
<code>[x *2 for x in range(1,N)] # 偶数列表</code></p>

<p>list和dict都有for in 循环，同时dict还有for key，value in 循环。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class=""><span class="line">for item in list:
</span><span class="line">for item in dict.itervalues():
</span><span class="line">for k,v in dict.iteritems():</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="section">文件操作</h2>

<p>文件常用的操作就是读写，创建，删除等。<br />
写文件，上面讲到<code>codecs</code>，他也可以用来读取。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class=""><span class="line">import codecs
</span><span class="line">with codecs.open('test.txt', 'r', 'utf-8') as f:
</span><span class="line">  		f.read()</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>读取文件的时候，假设这里有个需求是对A目录下面所有的json文件都读进来，组合成一个大的文件放到另一个目录文件中。<br />
那么我们首先要遍历这个文件，A里面有二级三级目录，都要读进来。<br />
因此可以使用如下方法</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class=""><span class="line">  	for root,dirs,files in os.walk(A):
</span><span class="line">		for file in files:
</span><span class="line">			fileBaseName,extention = os.path.splitext(file)</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这样通过extention是否等于json来判断是否是json文件了。<code>os.path.walk</code>也可以达到上述的效果。只是函数的调用方式不同。	我们写入文件是指定一个文件，如果该文件的目录不存在，这么写入是会爆粗的。因此在写入之前，要检查文件是否存在，不存在需要创建。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">if io.path.exists(dirName) == False:
</span><span class="line">	os.makedirs(dirName) #可以创建多级目录</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>与文件相关的函数，请访问os.path模块。相信有更多惊喜等着你哦！</p>

<h2 id="section-1">模块导入</h2>

<p>上面的例子中用到了import中，正如我们在php中看到的include，java中的import，swift中的import都一样，是导入其他的模块到当前py中，他的语法有以下几种：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class=""><span class="line">import A # 导入A模块
</span><span class="line">from A import B #导入A模块中的B，B可能是一个class，也可能是一个函数
</span><span class="line">import A as a #导入A模块，换个别名a
</span><span class="line">try:
</span><span class="line">	import A as a 
</span><span class="line">catch :
</span><span class="line">	import CA as a</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>最后一个try catch保证了优先导入A，如果没有A模块，在导入CA。但是都是别名a，这样我们py文件就不用任何修改。</p>

<p>模块导入的搜索路径：<code> sys.path</code><br />
也可以添加自己指定的搜索目录：sys.path.append(‘dirName’)和修改PYTHONPATH</p>

<p>接下来的分享还要类的使用和py调用外部命令等。放到下一章。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android In-app-billing 接入- 问题总结]]></title>
    <link href="http://www.newtomato.me/blog/2016/08/31/android-in-app-billing-jie-ru-wen-ti-zong-jie"/>
    <updated>2016-08-31T16:28:48+08:00</updated>
    <id>http://www.newtomato.me/blog/2016/08/31/android-in-app-billing-jie-ru-wen-ti-zong-jie</id>
    <content type="html"><![CDATA[<h2 id="section">准备过程</h2>
<p>接入Google支付之前，你要预先准备如下几件事情。</p>

<ol>
  <li>准备一个google开发者账号，绑定信用卡，在花费20美金。否则进入不了Google Play Developer Console。</li>
  <li>接下来，如果你身在大陆地区，那就你要学会翻墙。同时找一个没被阉割的android手机，这比较难，那就在已有的手机里面安装Google play store和Google Play Service。百度出来的不靠谱，因此最好能够先翻墙，然后google搜索上面两个安装包，安装即可。Android上的翻墙软件，推荐影梭，<a href="http://gjsq.me/1438224">GreenVPN</a>,<a href="http://itxs.co/s/14ff19gw">土行孙</a>。翻墙就祝各位好运了。<br />
<!--more--></li>
  <li>文档准备，看到全是英文Google支付接入文档，不少同学估计会头疼，此处刚好有一份<a href="http://www.baijingapp.com/question/6745">中文流程图</a>，大家可以参考借鉴一下，但最好还是能够通读一下他的开发文档。通过文档大概了解google支付的基本流程和几个概念。<strong>从文档中，我们可以看出Google支付和其他平台的支付最不一样的地方，那就是他需要先上传APK到后台，做成Alpha或者beta测试。然后把我们的小伙伴添加到测试名单中才能够发起支付。如果不发布应用，是无法测试的。PS：发布一个应用，不是瞬间完成的事情，至少等上2个小时，我创建了2个应用做测试，一个等了2个小时，一个等了一晚上。应用通过了，我们接下来才能测试。</strong>可是如果按照上述要求，我们如果修改了应用，是不是还要上传到后台呢？答案是不用，只要是下载过一次测试应用，接下来，我们只需要用相同的签名再次打包，直接覆盖安装到自己手机上即可测试。</li>
  <li>参考如下资料：
    <ol>
      <li><a href="http://leenjewel.github.io/blog/2014/11/21/google-play-in-app-billing-cai-guo-de-na-xie-keng/">Google Play In-app Billing 踩过的那些坑</a></li>
      <li><a href="http://www.jianshu.com/p/cff0f2333db6">Google In-app Billing 支付接入小结</a></li>
    </ol>
  </li>
  <li>下载Android Studio,尽早地熟悉使用它。google提供的Example就是这种工具做的工程。</li>
</ol>

<p>看到这里，基本工作是OK了。<br />
现在假设我们已经通过了成功创建了商品，发布了Alpha测试应用。测试支付，可以先将google的Example工程先做一下修改，然后打包扔上去就可以了。我们需要做的事情有<br />
## 打包<br />
1. 将申请应用的base64publicKey替换成自己的。<br />
<img src="http://7xuepc.com1.z0.glb.clouddn.com/2016-08-31-14726312121126.jpg" alt="" /><br />
2. 修改包名。原先是com.example换成你们想要的就行。然后清理工程重新编译。<br />
3. 修改配置文件中的包名和applicationId。<br />
其他保持不变，直接签名打包。提交上去等待审核通过吧。提交要提交到Alpha测试那里。而不是Production.</p>

<h2 id="section-1">测试购买</h2>
<p>接下来，讲讲怎么测试。<br />
开发者创建一个Google group或者google plus的社区，将测试同学的google邮箱添加进来。<br />
应用发布之后，会出现一个测试连接。<br />
<img src="http://7xuepc.com1.z0.glb.clouddn.com/2016-08-31-14726296504218.jpg" alt="-w=400" /><br />
将这个链接发给测试同学。此时他们打开这个链接才能成为有效的Tester。而不是加入到社区就可以了。<br />
然后在此链接的页面上有一个下载链接，此时就能够下载测试应用了。<br />
下载完成之后，接下来，我们开始测试支付。<br />
问题才刚刚开始哦！</p>

<ol>
  <li>
    <p>此版本的应用未配置通过Google Play结算。<br />
<img src="http://7xuepc.com1.z0.glb.clouddn.com/2016-08-31-Screenshot_2016-08-30-15-04-45.jpeg" alt="-w200" /><br />
解决方法：检查版本号和Google Play上设置的是否一致。检查签名等。Google那边基本认为这个应用不是一个有效的测试应用。</p>
  </li>
  <li>
    <p>需要验证身份，您需要登录自己的Google账户。<br />
<img src="http://7xuepc.com1.z0.glb.clouddn.com/2016-08-31-Screenshot_2016-08-31-15-55-46.jpeg" alt="-w200" /><br />
解决方法：打开手机设置-&gt;账户-&gt;删除Google账户。然后在应用管理中，找到Google Play Store，Google Play Service分别清理缓存数据。然后在打开Google Play商店。此时要求你账户登录。重新登录一遍。在杀死我们的测试应用，重新登录游戏。测试一下。这套方法能成功最好，如果不行，请换一个google账号再试一下。<br />
或者检查一下购买的商品Id在配置中是否一样。</p>
  </li>
  <li>
    <p>无法购买您要买的商品<br />
<img src="http://7xuepc.com1.z0.glb.clouddn.com/2016-08-31-Screenshot_2016-08-30-16-48-47.jpeg" alt="-w200" /><br />
解决方法：1. 检查是否自己的账号是不是测试账号，一定要是测试账号，不是开发者账号。怎么成为Tester，上面已经说过了。2. 商品的Id是否配置的正确。</p>
  </li>
</ol>

<p>遇到的所有的坑，总结下来就是：<br />
<strong>提交的包名，版本号，商品号，public key，签名等一定要和Google Play上面一致。<br />
Google Play Store是否正常，可以自己上去下载一个其他应用测试一下，如果这个应用能够打开支付，那么Google支付就是正常的。<br />
开发者账号和测试者账号要分开，猜想是Google Play服务后面有一些缓存的问题。</strong></p>

<p>运气好的话，一遍就能通过，如果不好，那就两遍。祝你好运吧。我花费了2天时间，才跑通了一个测试支付。希望你能比我运气好一些。不必这么痛苦。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[游戏引擎记录 - GameMaker]]></title>
    <link href="http://www.newtomato.me/blog/2016/08/28/you-xi-yin-qing-ji-lu-gamemaker"/>
    <updated>2016-08-28T19:17:58+08:00</updated>
    <id>http://www.newtomato.me/blog/2016/08/28/you-xi-yin-qing-ji-lu-gamemaker</id>
    <content type="html"><![CDATA[<p>GameMaker是一款制作2D游戏的引擎，支持跨平台发布游戏，Android，IOS，Win，Xbox，PS等。现在已经支持直接将游戏发布导出html5格式。1999 年 11 月发布了首个公开版本。早期是免费，4.3版本之后成为收费版本。</p>

<p>它提供自己的开发编辑器 Game Maker Studio和开发语言GML，语法简单。有1000个函数左右，能够满足所有的游戏需求。官方网站提供了几个简单的游戏demo，每个不过百行代码。极其简单，易于上手。<br />
<!--more--></p>

<p>游戏基于事件，通过拖拽控件到room中(就是场景)然后，在控件上写代码，检查控件位置，移动，和是否接受Input事件，以及是否和other物体碰撞，来判定控件的行动和改变控件的显示。比如切换控件的图片，sprite_index = 2即可。比如切换到其他房间go_to_room，或者设定计时器alarm。</p>

<p>此游戏引擎在做2d的闯关冒险游戏，射击有很大的优势。游戏流畅自如，比如下面两款游戏：</p>

<p><a href="http://www.yoyogames.com/showcase/2/defenders-of-ekron">defenders of ekron</a></p>

<p><img src="http://7xuepc.com1.z0.glb.clouddn.com/2016-08-28-14_feature.png" alt="14_feature" /></p>

<p><a href="http://www.cybernate.com/">SUPER MUTANT ALIEN ASSAULT</a><br />
<img src="http://7xuepc.com1.z0.glb.clouddn.com/2016-08-28-1033_feature.png" alt="1033_feature" /></p>

<p>游戏工具开发整体感受是-简单易用，语法相对于其他游戏语言简直不能太简单。且游戏打包之后体积相对于unity真的惊人的小。且国内不少这方面的开发者，在<a href="http://www.gamemaker.cn/">Game Maker开发者之家</a>里面很多人提供了一些源码工程。真心学习的话，一两个星期就可以上手了。且受益于前人的贡献，gamemaker的文档已被翻译成中文，<a href="http://f1.gamemake.org/gm/">地址</a>,<br />
<img src="http://7xuepc.com1.z0.glb.clouddn.com/2016-08-28-14723833105217.jpg" alt="" /></p>

<p>不过也有不足之处，首先游戏UI需要自己手写代码，和早期unity的GUI相似，暂时没有找到一些第三方比较好的UI编辑器。</p>

<p>其次，在Mac上的编辑器不如Windows好用，很多工程打不开。正如编译ios包，最好弄一台mac一样，使用这个引擎最好也能弄个Windows系统才可以。</p>

<p>再次，对于团队合作的项目，这个引擎是否合适？如果多人写作编辑同一个room之后，是如何解决冲突的？如果不能，是否是需要通过将功能划分，然后团队各负责一块儿的方式来协作？所以可能不适合大的团队，但是小团队，甚至个人开发者来说，这就不是问题了。</p>

<p>不得不说，这个引擎在快速出原型demo还是很不错的。个人认为甚至快于Unity。Unity自有他的好处。下次再说。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[整合FB广告步骤总结]]></title>
    <link href="http://www.newtomato.me/blog/2016/07/30/zheng-he-fbyan-gao-bu-zou-zong-jie"/>
    <updated>2016-07-30T12:09:50+08:00</updated>
    <id>http://www.newtomato.me/blog/2016/07/30/zheng-he-fbyan-gao-bu-zou-zong-jie</id>
    <content type="html"><![CDATA[<p>上一篇讲到整合Google广告到项目中，这次我们讲讲如何将FB的广告整合进来。</p>

<p>当然，使用FB的SDK，同样也需要翻墙。</p>

<p>首先我们先到FB的官方网站上面注册自己的应用。<br />
然后找到Facebook Audience Network的入口。在这里注册自己项目的基本信息。<br />
最后能够得到一个placementId，这个是我们最终需要用到的东西。<br />
然后开始集成 Facebook Audience Network 的SDK。<br />
<!--more--></p>

<h3 id="ios">整合到ios</h3>

<p>Facebook提供了两种方案实现。<br />
<strong>一种方案是使用POD方式</strong>，<strong>一种方案是自行下载FBAudienceNetwork的SDK</strong>，然后解压缩，将framework拖拽到项目库中。我个人比较推荐使用pod方式，如果依赖的库升级了，使用<code>pod update</code>就可以及时更新。省事省力省心。</p>

<ol>
  <li>使用pod 方式。首先在自己的项目目录下面，新建一个<strong>podfile</strong>文件。写入<code>pod 'FBAudienceNetwork'</code>。</li>
  <li>在项目目录下面，输入如下命令行<code>pod install</code>，pod命令会自行检查相关依赖库，然后将其下载下来。并且重新生成一个新的工程文件<code>xxx.xworkspace</code>。</li>
  <li>打开xworkspace的工程文件。在UIViewController的继承子类中修改代码如下</li>
</ol>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
</pre></td><td class="code"><pre><code class=""><span class="line">class GameViewController: UIViewController ,FBAdViewDelegate {
</span><span class="line">	override func viewDidLoad() {
</span><span class="line">        super.viewDidLoad()
</span><span class="line">        let adView:FBAdView = FBAdView.init(placementID: "221630757971535_844119255722679",
</span><span class="line">        adSize: kFBAdSizeHeight50Banner, rootViewController: self)
</span><span class="line">        adView.delegate = self;
</span><span class="line">        adView.loadAd();
</span><span class="line">        self.view.addSubview(adView);
</span><span class="line">    }
</span><span class="line">    ...</span></code></pre></td></tr></table></div></figure></notextile></div>

<ol>
  <li>然后运行代码即可。成功之后你会在屏幕顶端看到FB的广告。</li>
</ol>

<h3 id="android">整合到Android</h3>

<p>Facebook同样也是提供了两种方案实现。<br />
如果使用的是Android Studio，那么就可以使用<strong>gradle</strong>的方式，类似pod,也是写入配置，然后交由Android Studio来自行下载库。<br />
或者开发者自行下载sdk，解压缩之后将里面的AndienceNetwork.jar包拖到项目的libs文件夹下面。</p>

<p>接下来修改<strong>AndroidManifest</strong>文件，因为他需要有网络权限。因此需要增加如下两句权限配置</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">&lt;uses-permission android:name="android.permission.INTERNET"/&gt;
</span><span class="line">&lt;uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/&gt;</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>然后在我们的MainActivity修改成如下代码</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
</pre></td><td class="code"><pre><code class=""><span class="line">public class MainActivity extends AppCompatActivity {
</span><span class="line">
</span><span class="line">    private AdView adView;
</span><span class="line">    @Override
</span><span class="line">    protected void onCreate(Bundle savedInstanceState) {
</span><span class="line">        super.onCreate(savedInstanceState);
</span><span class="line">        setContentView(R.layout.activity_main);
</span><span class="line">        // Instantiate an AdView view
</span><span class="line">        adView = new AdView(this, "${从facebook申请到的placementId}", AdSize.BANNER_HEIGHT_50);
</span><span class="line">
</span><span class="line">        System.out.print("R.layout.content_main");
</span><span class="line">        // Find the main layout of your activity
</span><span class="line">        RelativeLayout layout = (RelativeLayout)findViewById(R.id.content);
</span><span class="line">
</span><span class="line">        // Add the ad view to your activity layout
</span><span class="line">        layout.addView(adView);
</span><span class="line">        adView.setAdListener(new AdListener() {
</span><span class="line">
</span><span class="line">            @Override
</span><span class="line">            public void onError(Ad ad, AdError error) {
</span><span class="line">                System.out.print("on error to show ");
</span><span class="line">            }
</span><span class="line">
</span><span class="line">            @Override
</span><span class="line">            public void onAdLoaded(Ad ad) {
</span><span class="line">                System.out.print("onAdLoaded ");
</span><span class="line">            }
</span><span class="line">
</span><span class="line">            @Override
</span><span class="line">            public void onAdClicked(Ad ad) {
</span><span class="line">               
</span><span class="line">                System.out.print("onAdClicked");
</span><span class="line">            }
</span><span class="line">
</span><span class="line">        });
</span><span class="line">			//第一次运行会在控制台输出此设备id，第二运行才会出现广告
</span><span class="line">        AdSettings.addTestDevice("%{设备id}");
</span><span class="line">
</span><span class="line">        // Request to load an ad
</span><span class="line">        adView.loadAd();
</span><span class="line">    }</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>此时在运行Android Studio，就可以在设备或者模拟器上看到广告了。文档里面说模拟器是不需要设备id的，但是我没有设备id，在模拟器上是看不到的。加上设备id，就可以看得到了。</p>

<p>至此FB广告整合就结束了，是不是非常简单？但是在实际操作中总会遇到其他各色的问题。但是请放心，只要翻墙翻得好，问题都会好！</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[调用漫威开发API]]></title>
    <link href="http://www.newtomato.me/blog/2016/07/27/diao-yong-man-wei-kai-fa-api"/>
    <updated>2016-07-27T16:03:31+08:00</updated>
    <id>http://www.newtomato.me/blog/2016/07/27/diao-yong-man-wei-kai-fa-api</id>
    <content type="html"><![CDATA[<p>无意间看到漫威原来也提供了开放API接口。真是让我惊喜意外。<br />
简单了看了一下他们的文档，看样子很简单就能够调用。不需要额外的登录和授权。<br />
API接口文档<a href="http://developer.marvel.com/docs">在此</a><br />
请求结构文档<a href="http://developer.marvel.com/documentation/generalinfo">在此</a></p>

<p>因此要调用他们接口，需要提供如下三个参数即可<br />
<!--more--></p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class=""><span class="line">Params: 
</span><span class="line">{   	"apikey": "your api key",   
</span><span class="line">		"ts": "a timestamp",   
</span><span class="line">		"hash": "your hash" 
</span><span class="line">}</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>第一个参数<strong>apikey</strong>是我们申请漫威开发者账号的时候，由他提供的一个<code>publick key</code>，（对应还有一个<code>private key</code>），第二个<strong>ts</strong>是一个时间戳，第三个hash是通过如下算法计算出来的</p>

<pre><code>	md5(ts+privateKey+publicKey)
</code></pre>

<p>例如，ts是1，public key是1234,private key是abcd，那么这个数字就是<code>md5(1abcd1234)</code></p>

<p>按照他的这个规则，我用Python写了一个简单的调用demo，代码下载下来，直接可用。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
</pre></td><td class="code"><pre><code class=""><span class="line">import httplib
</span><span class="line">import urllib
</span><span class="line">import json
</span><span class="line">import datetime
</span><span class="line">import time
</span><span class="line">from md5 import md5
</span><span class="line">
</span><span class="line">APIKEY = "1e8b043610d5ae2f4294eaf94dede6db"
</span><span class="line">PRIVATE_KEY = "32360edc7f06e025819a974ade95e513994761b1"
</span><span class="line">class BaseHttpRequest :
</span><span class="line">def __init__(self,action,param):
</span><span class="line">   self.mAction = action
</span><span class="line">   self.mParams = param
</span><span class="line">
</span><span class="line">def execute(self):
</span><span class="line">strRequest = "gateway.marvel.com" 
</span><span class="line">    	
</span><span class="line">headers = {"Accept":"application/json","Content-Type" : "application/json"}
</span><span class="line">
</span><span class="line">params = {}
</span><span class="line">params["apikey"] = APIKEY
</span><span class="line">    	
</span><span class="line">ts = time.time()
</span><span class="line">ts = int(ts)
</span><span class="line">params["ts"] = ts
</span><span class="line">strKey = "%s%s%s" % (ts,PRIVATE_KEY,APIKEY)
</span><span class="line">params["hash"] = md5(strKey).hexdigest()
</span><span class="line">params["limit"] = 1
</span><span class="line">params["offset"] = 1
</span><span class="line">params = urllib.urlencode(params)
</span><span class="line">strUrl = "/v1/public/%s?%s" % (self.mAction,params)
</span><span class="line">conn = httplib.HTTPSConnection(strRequest)
</span><span class="line">conn.request("GET",strUrl,None,headers) #params,headers
</span><span class="line">res = conn.getresponse()
</span><span class="line">    	
</span><span class="line">data = res.read()
</span><span class="line">jsonResult = json.loads(data)
</span><span class="line">   </span></code></pre></td></tr></table></div></figure></notextile></div>
<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class=""><span class="line">if __name__ == "__main__":
</span><span class="line">	#characters,comics,creators,events,stories
</span><span class="line">	request = BaseHttpRequest("stories",None)
</span><span class="line">	request.execute()</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>调用结果如下<br />
<img src="http://7xuepc.com1.z0.glb.clouddn.com/2016-07-27-14696064871563.jpg" alt="" /></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[cocos2dx 增加Google移动广告]]></title>
    <link href="http://www.newtomato.me/blog/2016/07/18/zheng-he-google-ads"/>
    <updated>2016-07-18T22:13:43+08:00</updated>
    <id>http://www.newtomato.me/blog/2016/07/18/zheng-he-google-ads</id>
    <content type="html"><![CDATA[<p>Google 提供一套广告的SDK，方便开发者将自己在自己应用中植入广告。国内不少的厂家也在做这样的SDK，比较有名的就是触控下面的AnySDK。<br />
<img src="http://7xuepc.com1.z0.glb.clouddn.com/2016-07-18-any.jpeg" alt="any" /></p>

<p>但是AnySDK是一个大而全的东西，而我们只需要广告接入这一小块儿的东西。同时，我们的cocos2dx的版本是2.2.6，相对于触控的3.18，已经有很大差别。</p>

<p>于是我们需要自己在重新造一遍轮子，幸运的是网上有不少这样的材料。</p>

<ol>
  <li>Firebase提供的文档刚好有与cocos2x相关的资料，<a href="https://firebase.google.com/docs/admob/android/games?hl=zh-cn">移步至此</a>,</li>
  <li>还有热心的同学贴出了更详细的步骤<a href="http://www.cnblogs.com/qianyuming/p/5023018.html">cocos2dx-3.9 集成admob</a>。</li>
  <li>
    <p><a href="https://firebase.google.com/docs/admob/ios/quick-start?hl=zh-cn">入门基础指导</a><br />
<!--more--><br />
参考了上面的资料，我还是遇到了不少问题。</p>
  </li>
  <li>
    <p>首当其冲的就是<strong>安装CocoaPods</strong> ，可以参考下面两篇文章。</p>

    <ol>
      <li><a href="http://blog.csdn.net/wuquan0625/article/details/47401235">pod install速度慢的终极解决方案</a>。</li>
      <li><a href="http://www.cnblogs.com/qianyuming/p/5012578.html">cocoapod安装过程中的幺蛾子</a></li>
    </ol>
  </li>
  <li>一定要下载最新的googlemobilesdk版本，<a href="https://firebase.google.com/docs/admob/ios/download?hl=zh-cn">地址在此处</a>,我当前用的是v7.9.0。</li>
  <li>我们的项目不仅仅会依赖上面的<code>GoogleMobileAds.framework</code>，还依赖一下的framework，请在target-&gt; build phase -&gt; frameworks中找出来。此处我也是被坑到了，总是提示类似<code>"_OBJC_CLASS_$_SFSafariViewController", referenced from: "_CMTimeMakeWithSeconds", referenced from: l3880 in GoogleMobileAds(flat-arm64)"</code>这样的错误，究其原因就是没有找到对应的framework。</li>
</ol>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class=""><span class="line">CoreMideia.framework,SafariServices.framework,
</span><span class="line">CoreBluetooth.framework,MessageUI.framework,
</span><span class="line">AdSupport.framework,EventKit.framework,EventKitUI.framework,
</span><span class="line">AudioToolbox.framework,MediaPlayer.framework,
</span><span class="line">StoreKit.framework,SystemConfiguration.framework,
</span><span class="line">CoreTelephony.framework,CoreGraphics.framework,
</span><span class="line">AVFoundation.framework</span></code></pre></td></tr></table></div></figure></notextile></div>

<ol>
  <li>clean-&gt;build project</li>
  <li>在模拟器上运行，Google Ads会自动加载测试的广告。但是如果要在真机上测试，需要打开真机上关闭广告跟踪的功能。在手机的设置-&gt;隐私-&gt;广告里面。关闭即可。</li>
  <li>运行项目从输出控制台先拿到测试设备号。然后填写到下面的位置。再次运行。</li>
</ol>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">GADRequest *request = [GADRequest request];
</span><span class="line">request.testDevices = @[@"测试设备号"];</span></code></pre></td></tr></table></div></figure></notextile></div>
<ol>
  <li>设备上测试，还要考虑装一个VPN。</li>
  <li>如果首次没有显示出来，并且控制台也没有报错，估计就是网络响应慢导致的问题。可以多次尝试即可。</li>
  <li>Google 提供了一个example工程。<a href="git@github.com:googleads/googleads-mobile-ios-examples.git">地址</a>,可以先调通这个工程，那么整合到cocos2dx中也就不是什么事儿了！</li>
</ol>

<p>上述是我花费了大半天的时间，踩了不少坑，才将这套流程走通。并且仅仅是展示了Banner广告。<br />
先看一下效果吧。接下来的计划就是调通控制广告播时长的接口。</p>

<p><img src="http://7xuepc.com1.z0.glb.clouddn.com/2016-07-18-IMG_0511.png" alt="IMG_0511" /></p>

]]></content>
  </entry>
  
</feed>
