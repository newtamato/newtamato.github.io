<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[番茄手册]]></title>
  <link href="http://www.newtomato.me/atom.xml" rel="self"/>
  <link href="http://www.newtomato.me/"/>
  <updated>2018-06-12T18:48:06+08:00</updated>
  <id>http://www.newtomato.me/</id>
  <author>
    <name><![CDATA[newtomato]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[在lua项目中使用luacov进行代码覆盖率的测试]]></title>
    <link href="http://www.newtomato.me/blog/2018/06/12/luacov-test"/>
    <updated>2018-06-12T18:46:43+08:00</updated>
    <id>http://www.newtomato.me/blog/2018/06/12/luacov-test</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/norman/luacov">luacov</a>是一个轻量级的代码覆盖率的检查工具。他总是和busted这个单元测试框架一起被人提到。</p>

<p>今天刚好我准备把他集成到项目中。先来个例子展示一下怎么使用。两个测试lua文件如下:</p>

<!--more-->

<h2 id="section">文件准备</h2>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
</pre></td><td class="code"><pre><code class=""><span class="line">function Add(a,b)--func.lua
</span><span class="line">	return a+b
</span><span class="line">end
</span><span class="line">
</span><span class="line">function Remove(a,b)
</span><span class="line">	return a-b
</span><span class="line">end
</span><span class="line">
</span><span class="line">function MissFunc(a,b)
</span><span class="line">	return "i will be missed"
</span><span class="line">end
</span></code></pre></td></tr></table></div></figure></notextile></div>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class=""><span class="line">require("func")--funcTest.lua
</span><span class="line">r = Add(1,3)
</span><span class="line">print(r)
</span><span class="line">r = Add(2,3)
</span><span class="line">print(r)
</span><span class="line">r = Remove(3,1)
</span><span class="line">print(r)</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="section-1">开始运行</h2>

<p>然后在命令行下运行：</p>

<p><code>lua -lluacov funcTest.lua</code></p>

<p>此时若没有语法错误，则会在funcTest同级目录下面生成一个<code>luacov.stats.out</code>文件。然后将这个打开看看。好像不是很明白。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class=""><span class="line">11:./func.lua
</span><span class="line">1 2 1 0 1 1 1 0 1 0 2 
</span><span class="line">7:funcTest.lua
</span><span class="line">1 1 1 1 1 1 1 
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>第一行7表示func.lua有7行代码，第二行就表示func.lua每一行被调用的次数。Add函数注册1遍，但函数体被调用两次。<br />
但是这样看起来很不方便，所以我们在此调用如下命令：</p>

<p><code>luacov .</code></p>

<p>此时又新生成了<code>luacov.report.out</code>文件。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
</pre></td><td class="code"><pre><code class=""><span class="line">==============================================================================
</span><span class="line">./func.lua
</span><span class="line">==============================================================================
</span><span class="line"> 1 function Add(a,b)
</span><span class="line"> 2 	return a+b
</span><span class="line">   end
</span><span class="line">
</span><span class="line"> 1 function Remove(a,b)
</span><span class="line"> 1 	return a-b
</span><span class="line">   end
</span><span class="line">
</span><span class="line"> 1 function MissFunc(a,b)
</span><span class="line">*0 	return "i will be missed"
</span><span class="line">   end
</span><span class="line">
</span><span class="line">==============================================================================
</span><span class="line">funcTest.lua
</span><span class="line">==============================================================================
</span><span class="line"> 1 require("func")
</span><span class="line"> 1 r = Add(1,3)
</span><span class="line"> 1 print(r)
</span><span class="line"> 1 r = Add(2,3)
</span><span class="line"> 1 print(r)
</span><span class="line"> 1 r = Remove(3,1)
</span><span class="line"> 1 print(r)
</span><span class="line">
</span><span class="line">==============================================================================
</span><span class="line">Summary
</span><span class="line">==============================================================================
</span><span class="line">
</span><span class="line">File         Hits Missed Coverage
</span><span class="line">---------------------------------
</span><span class="line">./func.lua   5    1      83.33%
</span><span class="line">funcTest.lua 7    0      100.00%
</span><span class="line">---------------------------------
</span><span class="line">Total        12   1      92.31%
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>看起来顺眼多了，尤其是最后的Summary，可以看到那些函数被调用Hit，那么没有Missed,func里面的MissFunc有定义，但是没有被调用过，所以Missed！</p>

<p>这样一来那些函数被用到，那么没有用到，果然是清晰了很多。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Godot引擎分析-1]]></title>
    <link href="http://www.newtomato.me/blog/2018/05/26/godot-1"/>
    <updated>2018-05-26T13:06:57+08:00</updated>
    <id>http://www.newtomato.me/blog/2018/05/26/godot-1</id>
    <content type="html"><![CDATA[<p>利用业余时间看了一个星期的godot源码，云里雾里的看不清全貌。记录一下这周的成果，为以后先打个基础。</p>

<p>此处声明，由于个人并没全部看明白，所以我只是分享一部分我看到的东西。我的分享未必都是全部正确的。如果有错误也非常欢迎指正出来。正所谓互相交流才能有所进步。</p>

<p>ok，闲话少说进入正题。<br />
<!--more--></p>

<h2 id="section">宏观角度看</h2>

<p>先从整体宏观的角度看一下GoDot引擎。<br />
<img src="http://7xuepc.com1.z0.glb.clouddn.com/2018-05-26-15272453730540.jpg" alt="" /></p>

<p>从上面这张图上看，我们可以看出一下几点：</p>

<ul>
  <li>最上层<code>MainLoop</code>就是我们的游戏循环逻辑。所有游戏几乎都会有自己的main入口，然后在main函数中做到循环刷新屏幕。Godot也不例外。</li>
  <li>所有对象都继承自Object，Reference也是继承Object，只有Resource资源继承自Reference。Node，Canvas等显示对象却并不继承Reference。这和其他引擎不太一样。例如在cocos中所有对象都继承自Reference，几乎可以通过调用RefCount来检查对象的被引用的个数。</li>
  <li>Node有两大子类型，一个是<code>Canvas</code>，一个是<code>Spatial</code>。主要区别在于，<code>Canvas</code>是2d对象的父类，对应的<code>Spatial</code>是所有3D的父类。Canvas下又分成了<code>Control</code>和<code>Node2d</code>，<code>Control</code>是所有UI的父类，<code>Node2d</code>是所有2d物体的父类。例如我们实例化一个button，Lable，PopUpDialog，他们都是继承自Control。而我们实例化的<code>Sprite</code>，<code>Area2d</code>，都是继承自Node2d。为什么godot会将UI和Node2d区别对待呢？是因为底层对UI层做了优化，可以提升引擎的性能。怎么做到的呢？那就涉及到第四点。</li>
  <li>第二层是开发同学会经常用到的。创建一个物体，给他配上Texture或者Shader，Material。旋转移动物体，去碰撞另外一个物体等等。而这些效果背后真正实现他们，就是第三层。这一层包括物理引擎和渲染引擎还有声音。物理引擎就是负责告诉我们碰撞以及类似Camera需要渲染多少个物体。所以最关键的地方在于高效的碰撞检测算法。渲染引擎负责将Texture，Material，Shader等融合在一起，计算物体的Transform矩阵，准备顶点数据光照数据环境数据然后调用OpenGL命令上传GPU。</li>
</ul>

<p>上面的那张图大概介绍完了。很多同学估计对第三层很感兴趣，但是现在不是合适的时候。我们需要一步一步的来。</p>

<h3 id="section-1">从代码结构来看</h3>

<p>现在来说一下他的代码结构。了解代码结构有助于辅助我们看懂他的代码。从github上将他的代码clone下来之后，代码结构如下：</p>

<p><img src="http://7xuepc.com1.z0.glb.clouddn.com/2018-05-26-15273033285621.jpg" alt="" /><br />
这些大部分目录我们不用都去看，</p>

<pre><code>core：是对数据结构的定义。
platform：是各个平台一些不同处理。
doc：我们使用godot编辑器的时候，一些代码提示和文档。
scene：是第二层的实现。
main：就是第一层的实现。main入口类。以及mainloop等。这里会做初始化的一些操作。
modules：是一些模块的处理，字体，图片格式解析等。
servers：是第三层的实现。
thirdparty：暂时还没有没有看到。
editor：就是godot编辑器的实现。
</code></pre>

<p>看了上面的解释，是不是知道重点在哪里了。对！就是<strong>scene和servers</strong>。</p>

<p>scene主要是第二层的实现。包括2d，3d，gui，resource（例如texture，mesh，material，collision shape）。<br />
servers就是第三层的实现。<br />
<img src="http://7xuepc.com1.z0.glb.clouddn.com/2018-05-26-15273037073232.jpg" alt="" /><br />
audio就不用说了，visual是负责渲染，physics_2d是2d的物理引擎。physics是3d的物理引擎。arvr就是时下较为流行的ARVR技术了。</p>

<p>所以如果你对任何一块儿感兴趣可以直接去看代码。看他是怎么实现的。不过相信我，硬啃代码绝对是事倍功半的买卖。</p>

<h2 id="section-2">通过一个例子来将整个引擎串起来</h2>

<p>从宏观的角度讲这么多，我们现在通过一个例子，将引擎怎么工作的给串起来。然后在从微观角度，更细节的去分析他的实现。</p>

<p>这个例子是：</p>

<p><strong>将一个Sprite放到舞台上，并给他一张图片，他是怎么被绘制屏幕上的？</strong></p>

<p>这个题目经常是一个前端工程师的面试题目。不同面试官有不一样的点。我这里并不给出答案，只是将流程说一下，所有点都在这里了。你们自行体会。</p>

<h2 id="section-3">应用业务层</h2>

<p>代码实现</p>

<pre><code>var sprite = Sprite.new()
var texture = ImageTexture.new()
texture.load("res://MainForm/bg_activityout.png")
sprite.centered = false
sprite.set_texture(texture)	
self.add_child(sprite)
</code></pre>

<p>ImageTexture加载图片的函数：</p>

<pre><code>void ImageTexture::load(const String &amp;p_path) {

	Ref&lt;Image&gt; img;
	img.instance();
	img-&gt;load(p_path);
	create_from_image(img);
}
</code></pre>

<p>Image位于core文件夹，是对图片信息的解析实现。不同格式的图片有各自的存储格式，比如说每个像素是按多少字节存储。而我们知道的是p_path即可。<br />
然后看看<code>create_from_image</code>函数。</p>

<pre><code>void ImageTexture::create_from_image(const Ref&lt;Image&gt; &amp;p_image, uint32_t p_flags) {

	ERR_FAIL_COND(p_image.is_null());
	flags = p_flags;
	w = p_image-&gt;get_width();
	h = p_image-&gt;get_height();
	format = p_image-&gt;get_format();

	VisualServer::get_singleton()-&gt;texture_allocate(texture, p_image-&gt;get_width(), p_image-&gt;get_height(), p_image-&gt;get_format(), p_flags);
	VisualServer::get_singleton()-&gt;texture_set_data(texture, p_image);
	_change_notify();
}
</code></pre>

<p>这个函数出现的如下两句就比较关键了：</p>

<p>VisualServer::get_singleton()-&gt;texture_allocate(texture, p_image-&gt;get_width(), p_image-&gt;get_height(), p_image-&gt;get_format(), p_flags);<br />
		VisualServer::get_singleton()-&gt;texture_set_data(texture, p_image);</p>

<p>这两个函数的实现就是开始调用opengl创建glBindTexture，glTexImage2D，然后将<code>tex_id</code>这个opengl句柄，赋值给我们刚刚创建的texutre。</p>

<p>VisualServer在platform那里初始化<strong>VisualServerRaster</strong>。但是它并没有texture_allocate函数，这个函数的真正实现是在<code>RasterizerStorageGLES3</code>或者<code>RasterizerStorageGLES2</code>，为什么会这么调用呢？这里算是给大家的一点思考。</p>

<h3 id="opengl">渲染层，设置opengl状态</h3>

<p>ok，我们直接来看一下第一个函数吧。</p>

<p>void RasterizerStorageGLES3::texture_allocate(RID p_texture, int p_width, int p_height, Image::Format p_format, uint32_t p_flags) {</p>

<pre><code>GLenum format;
GLenum internal_format;
GLenum type;

bool compressed;
bool srgb;

if (p_flags &amp; VS::TEXTURE_FLAG_USED_FOR_STREAMING) {
	p_flags &amp;= ~VS::TEXTURE_FLAG_MIPMAPS; // no mipies for video
}

Texture *texture = texture_owner.get(p_texture);
ERR_FAIL_COND(!texture);
texture-&gt;width = p_width;
texture-&gt;height = p_height;
texture-&gt;format = p_format;
texture-&gt;flags = p_flags;
texture-&gt;stored_cube_sides = 0;
texture-&gt;target = (p_flags &amp; VS::TEXTURE_FLAG_CUBEMAP) ? GL_TEXTURE_CUBE_MAP : GL_TEXTURE_2D;

_get_gl_image_and_format(Ref&lt;Image&gt;(), texture-&gt;format, texture-&gt;flags, format, internal_format, type, compressed, srgb);

texture-&gt;alloc_width = texture-&gt;width;
texture-&gt;alloc_height = texture-&gt;height;

texture-&gt;gl_format_cache = format;
texture-&gt;gl_type_cache = type;
texture-&gt;gl_internal_format_cache = internal_format;
texture-&gt;compressed = compressed;
texture-&gt;srgb = srgb;
texture-&gt;data_size = 0;
texture-&gt;mipmaps = 1;

glActiveTexture(GL_TEXTURE0);
glBindTexture(texture-&gt;target, texture-&gt;tex_id);

if (p_flags &amp; VS::TEXTURE_FLAG_USED_FOR_STREAMING) {
	//prealloc if video
	glTexImage2D(texture-&gt;target, 0, internal_format, p_width, p_height, 0, format, type, NULL);
}

texture-&gt;active = true; }
</code></pre>

<p>这个函数先是将Image读出来的p_width,p_height,p_format 等数据都赋值给texture，同时格局p_format来求出opengl需要的internal formate和formate，这两个参数在下面glTexImage2D是用得到的。我们例子中texture的target是GL_TEXTURE_2D。因此这里不会调用glTexImage2D。</p>

<p>opengl加载一个Texture需要有以下几个步骤。<br />
激活一个Texture，绑定到一个opengl变量上，设置他的状态，绑定图片数据。<br />
刚才那个函数并没有完成后续的步骤，所以我们还需要继续向下看，那就是看<code>texture_set_data</code>函数。<br />
这个函数代码太长，这里就不贴出来了。但是从这个代码中我们确实看到了他开始设置状态，绑定图片数据了。</p>

<p>至此，opengl状态已经设定完成。但还没有完，图像真正显示出来，是需要drawcall的。在何处，在何时进行的呢？</p>

<h3 id="gldraw">渲染层，开始glDraw*绘制</h3>

<p>这里的绘制是一个复杂的过程，我尽量以流程图的形势画出来。希望让大家有一个清晰的印象。<br />
<img src="http://7xuepc.com1.z0.glb.clouddn.com/2018-05-26-15273102726934.jpg" alt="" /></p>

<p>所有的渲染命令会被添加到canvas对象的command队列中，而我们循环刷新逻辑在每帧去调用render_canvas，VisualServersCanvas有所有canvas对象，于是遍历循环开始。只要有canvas对象上有command队列就开始调用_canvas_item_render_command函数去<code>glDraw*</code></p>

<p>流程图不复杂，点到为止，你们按照上面的函数名挨个看下去，就能更清晰明了了。</p>

<h2 id="section-4">结束前的话</h2>

<p>相信看过代码的同学一定有很多困惑，里面那么多的状态设置，那么多if的分支都是干什么用的。感觉我说的很简单，但是代码讲了好多事情。不那么简单啊！<br />
是的，你说对了，因为我的业务简单，只绘制了一个Sprite，但是如果考虑到shader，考虑到混合，考虑到透明，考虑到光线等等，在回头去看绘制函数，是不是就有点明白了。<br />
因此要想真正搞明白绘制函数，需要对opengl有一定的了解，什么是vbo，vao，ufo，fbo以及如何更新数据等等。</p>

<p>接下来，我会从比较细节的地方去看引擎，顺便对opengl的接口函数做一下梳理。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Godot基础知识之事件穿透]]></title>
    <link href="http://www.newtomato.me/blog/2018/05/20/godot-event-1"/>
    <updated>2018-05-20T20:03:02+08:00</updated>
    <id>http://www.newtomato.me/blog/2018/05/20/godot-event-1</id>
    <content type="html"><![CDATA[<h2 id="section">什么是事件穿透</h2>

<p>场景上有一个物体A，B，B被A挡住，也就是我们能看到B的一部分。此时我们点击A（只有A的部分，没有挡住B的那部分），A会收到点击事件的通知。但是此时如果我们点击A，B交汇处，会发生什么？这就需要我们具体想让什么先发生。<br />
A，B均可以收到点击事件。收到事件会有一个先后顺序。一般会以显示顺序排序，前面的A会先收到。A收到之后，决定事件是否继续向下传递。如果传递了，就发生穿透。</p>

<p>大部分情况下，我们看到UI下面遮挡场景。点击UI，只希望UI收到点击事件。而UI下面遮挡的场景并不希望收到事件。事件由引擎触发，而由我们来决定是否终止。</p>

<p><code>EventSystem.current.IsPointerOverGameObject(Input.GetTouch(0).fingerId)</code>(用在u3d中)函数检测是否是在UI层，在cocos中，我们使用<code>onTouchBegan()</code>的返回值来判定是否被他吞掉。而在godot中是怎么实现的呢？</p>

<!--more-->

<h2 id="section-1">进入正文</h2>

<p>先来看看godot怎么解释他的input事件。<br />
<img src="http://7xuepc.com1.z0.glb.clouddn.com/2018-05-20-152681301816391.png" alt="" /><br />
User触发了点击事件之后，事件在SceneTree中一直被传递。执行格子_input函数。从图中可以看出，先要寻找_input,如果没有_input最后会寻找_unhandled_input函数。</p>

<p>看这种图也不是很直观。我们来做一个测试。<br />
<img src="http://7xuepc.com1.z0.glb.clouddn.com/2018-05-20-15268241267894.jpg" alt="w350" /><br />
展示的样子是：<br />
<img src="http://7xuepc.com1.z0.glb.clouddn.com/2018-05-20-15268237116454.jpg" alt="w350" /></p>

<p>连个button，同时button下面还有一个Area。<strong>TestClick和Hud和Area均带有_input函数</strong>，当我点击button1的时候，输出的打印日志如下：</p>

<pre><code>[Hud]_input
[Area2]_input
[Area]_input
[TestClick]_input
[Hud]_on_Button_pressed
</code></pre>

<p>事件流是<strong>Hud:_input-&gt;Area2:_input-&gt;Area:_input-&gt;TestClick:_input-&gt;Hud.btn1的点击回调</strong>。</p>

<p>也就是在input事件发生的时候，Node只要有input函数，都会被执行一遍。<strong>注意这里只有button被执行，挡在后面的其他对象（他们都带有真正触发事件的_input_event函数）并没有触发。所以这里已经可以算是方案了</strong></p>

<h3 id="section-2">问题</h3>

<p><strong>如果想要在hud的input先发生，其他的input函数在后面执行，怎么办？</strong></p>

<p>API文档中提供了一个函数：<code>accept_event</code>。我们放到hud的input函数内。</p>

<pre><code>func _input(event):
	if event.is_pressed():
		print("[Hud]_input")
		accept_event()
</code></pre>

<p>结果打印就是：</p>

<pre><code>[Hud]_input
</code></pre>

<p>Button函数没有执行啊！这明显不是我们想要的。</p>

<p>幸运的是，我们还有一个<code>_unhandled_input</code>函数。此时我们将Area和TestClick的input函数全部换成这个函数。然后再次点击btn1，看看输出结果。</p>

<pre><code>[Hud]_input
[Hud]_on_Button_pressed
</code></pre>

<p>哈！达到了我们的基本目的，只有hud收到了事件。那么如果此时点击非Hud的地方会怎么样？比如我们直接点击非HUD，非Area（蓝色块）的那个黑色地方，看看输出吧。</p>

<pre><code>[Hud]_input
[Area2]_unhandled_input
[Area]_unhandled_input
[TestClick]_unhandled_input
</code></pre>

<p>这样看来事件流便是 <strong>Hud:_input-&gt;Area2:_unhandled_input-&gt;Area:_unhandled_input-&gt;TestClick:_unhandled_input</strong>。</p>

<p>此时在点击蓝色块的Area，他有一个_input_event()的函数，打印如下：</p>

<pre><code>[Hud]_input
[Area2]_unhandled_input
[Area]_unhandled_input
[TestClick]_unhandled_input
[Area]_on_Area_input_event
</code></pre>

<p>上述打印一定要认真看他们的顺序。</p>

<h2 id="section-3">结论</h2>

<p>那么我们直接先来看看结论:</p>

<p><strong>如果点击是发生在hud（control）上，他会触发所有的input函数。无论是control还是Area上的。如果不是发生在hud上的点击，则按照input先触发，在触发_unhandled_input的顺序去触发。</strong></p>

<p>所以再来看我们原先的问题：</p>

<p><strong>如何让hud的input优先级高于其他Node呢？</strong></p>

<p>相信读到这里的读者已经有些答案了，那就是让hud拥有input函数，其他Node只有_unhandled_input。亦或者真正的事件发生不要写在input中，而是在input_event中。input_event是按照显示顺序，在前面的对象如果有这个函数，后面的对象则不触发了。</p>

<p>好了，分享到此结束了。大家有更好的方法欢迎和我交流。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Godot基础知识之Transform坐标转换]]></title>
    <link href="http://www.newtomato.me/blog/2018/05/19/godot-transform-1"/>
    <updated>2018-05-19T21:45:56+08:00</updated>
    <id>http://www.newtomato.me/blog/2018/05/19/godot-transform-1</id>
    <content type="html"><![CDATA[<h2 id="section">为什么要介绍坐标矩阵 ？</h2>

<p>Godot是一个开源的游戏引擎，支持2D和3D，如果你好奇Unity里面的那些炫酷特效是怎么实现的，又苦于没有unity3d的源码，那么可以考虑阅读Godot源码来帮助你梳理3D的知识库。</p>

<p>从渲染的角度上看，3D和2D在差别不大，都是需要将Texture和顶点（Mesh）数据，位置信息，颜色，法线等数据提交到GPU那边。渲染采用语言有所不同，有的采用opengl也有用d3d。<br />
现在渲染管线支持可编程，可以通过编写顶点片段着色器去修改图像最终的显示效果。</p>

<p>但是从计算的角度而言，3D还比2D多一个轴，因为这个轴，涉及了很多坐标变化，矩阵转换可以说是3D开发过程中当之无愧的基础。点击事件最终会通过坐标转换，来决定是否点中某个带碰撞盒的物体，物理引擎模拟运动，也离不开矩阵转化。最普遍的碰撞事件，大量物体在场景中运动（暂且不考虑性能问题），最终检测两个物体是否碰撞，也是需要位置坐标等，比如基础的AABB盒碰撞。坐标矩阵的转换涉及到很多地方，例如投影矩阵的计算，常用的法线贴图是以切线空间为坐标系。存储也是3d坐标，最后还需要用模型的矩阵来获得法线转换矩阵。</p>

<p>所以说矩阵非常重要。<br />
而今天我们先来了解一下Godot中坐标是一个什么样子的？原点在何处？坐标如何转换。<br />
<img src="http://7xuepc.com1.z0.glb.clouddn.com/2018-05-19-icon.png" alt="icon" /><br />
<!--more--><br />
## 进入正题</p>

<p>废话不多说了。开始吧。<br />
我们的目的是通过点击屏幕，得到他屏幕坐标，ViewPort坐标，以及里面Area坐标。</p>

<p>首先我们创建一个空的godot工程，并且创建一个空的场景，里面放置一个Node。命名TestClick。<br />
然后增加一个Area，并且为他添加一个Shape（用于碰撞），和Mesh用于展示他的样子的。<br />
<img src="http://7xuepc.com1.z0.glb.clouddn.com/2018-05-19-15267174988040.jpg" alt="" /></p>

<p>此时一定要增加一个Camera，否则运行之后场景里面看不到任何东西。</p>

<p>然后在Area上绑定一个脚本。增加<code>_input(event)</code>和<code>_input_event(camera, event, click_position, click_normal, shape_idx)</code>两个函数。后一个需要connect一下。<br />
代码如下：</p>

<pre><code>func _input(event):
	if event.is_pressed():
		print("[_input]",event.get_instance_id())
		print("[_input]",event.position)	
func _on_Area_input_event(camera, event, click_position, click_normal, shape_idx):
	if event.is_pressed():
		print("[_input_event] ",event.get_instance_id())
		print("[_input_event]",click_position)
		print("[_input_event]",click_normal)
		print("[_input_event]",shape_idx)
		var newpos = global_transform.affine_inverse() * click_position
		print("[_input_event]",newpos)
		newpos.y = newpos.y * -1
		newpos += Vector3(1,1,0)
		newpos /= 2
		print("[_input_event]",newpos)
	pass # replace with function body
</code></pre>

<p>通过这些打印，可以得知，每次点击会触发这两个函数，但是传递的event并不是同一个对象。<br />
event.position是屏幕坐标，根据你的屏幕分辨率计算出来的屏幕坐标，是一个Vector2类型。<br />
而click_position则是一个Vector3类型的坐标，但是并不是Area的点击位置坐标，而是当前屏幕的点击坐标，是当前ViewPort的点击坐标。<br />
这里说一下ViewPort的原点和坐标系。ViewPort的坐标系类似如下图片。<br />
<img src="http://7xuepc.com1.z0.glb.clouddn.com/2018-05-19-15267189437356.jpg" alt="" /><br />
ViewPort是屏幕以屏幕的正中心为原点，x向右为正方向，y向上为正方向。正交投影下，ViewPort的区间是[-1，1]。但是Camera选择是透视投影，调整Camera的视角和far，near之后，区间就会发生变化。点击屏幕四个角，输出坐标。比较一下即可。<br />
但是我们需要的不是viewport坐标，而是Area的坐标，设置可以说是Area的屏幕坐标。</p>

<p>因此需要将viewport坐标转换成Area，使用的函数就是如下函数：</p>

<pre><code>var newpos = global_transform.affine_inverse() * click_position
</code></pre>

<p><code>global_transform</code>是Area的全局变换。我们求得他的逆转换。然后对<code>click_position</code>进行这个逆转换。就可以将viewport的坐标转成Area的本地坐标。这里注意的是：Area的坐标系和ViewPort一样，x,y的范围是[-1,1],也就是他的原点在Area的中心，为了转换成我们熟悉的原点坐标在左上角。还是需要对他进行特殊处理。</p>

<pre><code>newpos.y = newpos.y * -1
newpos += Vector3(1,1,0)
newpos /= 2
</code></pre>

<p>此时newpos的x，y就是以左上角为原点的。</p>

<p>另外一些提示，我们添加的是Node，那里有viewport呢？那么问题来了，TestClick是根节点么？<br />
在它的_ready()函数中，我们添加如下代码，看看根到底是个什么对象。</p>

<pre><code>print(get_node("root"))
</code></pre>

<p>打印出来是<strong>ViewPort</strong>,非常意外。原来我们增加的Node并不是根，而是根里面第一个子节点。</p>

<h2 id="section-1">扩展</h2>

<p>如果要将area里面的本地坐标转换成全局坐标怎么做呢？<br />
调用他的to_global()函数即可。全局坐标转换为本地坐标呢？to_local()!<br />
看看他的函数代码：</p>

<pre><code>Vector3 Spatial::to_local(Vector3 p_global) const {
	return get_global_transform().affine_inverse().xform(p_global);
}
Vector3 Spatial::to_global(Vector3 p_local) const {
	return get_global_transform().xform(p_local);
}
</code></pre>

<p>我们刚刚的工程里面刚好可以直接使用to_local()即可。不用非得自己用transform来转换了。<br />
而上面这些矩阵转换和unity除了用法不同，原理是一样的。ViewPort的坐标原点不同，Unity中ViewPort的原点在左下角，右上角是（1，1）。并且转换世界坐标到本地坐标，和本地到世界坐标的转换。使用的Transform.transformPoint()以及InverseTransformPoint()。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[记一个华为手机上声音突然消失不见的bug]]></title>
    <link href="http://www.newtomato.me/blog/2018/05/17/bugji-lu"/>
    <updated>2018-05-17T18:57:53+08:00</updated>
    <id>http://www.newtomato.me/blog/2018/05/17/bugji-lu</id>
    <content type="html"><![CDATA[<p>背景是这样的。我们的项目需要播放许多声音。只是在部分华为的设备上声音会突然消失，然后过一会儿声音又再次出现。<br />
这个问题没有什么规律可循。<br />
一开始针对华为手机的MediaPlayer进行查找。找到的原因在<a href="https://blog.csdn.net/jiangtianhao13269230/article/details/78821932">此处</a>，认为是MediaPlayer没有被释放导致内存泄漏。但是我们及时调用了释放函数，还是没有解决问题。<br />
<!--more--></p>

<p>后来，通过monitor打印的日志，对正确播放声音和没有播放声音的日志进行对比发现了如下不同之处：</p>

<pre><code>05-17 17:19:43.658: E/AudioFlinger(685): no more track names available
05-17 17:19:43.658: E/AudioFlinger(685): createTrack_l() initCheck failed -12; no control block?
05-17 17:19:43.658: W/AudioFlinger(685): AudioException  mNotificationClients.keyAt(i)  pid=551
05-17 17:19:43.658: W/AudioFlinger(685): AudioException  mNotificationClients.keyAt(i)  pid=685
05-17 17:19:43.658: W/AudioFlinger(685): AudioException  mNotificationClients.keyAt(i)  pid=1200
</code></pre>

<p>google这个<strong>no more track names available</strong>关键词。果然有所发现。<br />
在Stack Overflow上有个相似的<a href="https://stackoverflow.com/questions/8388053/soundpool-error-no-more-track-names-available">问题</a>。</p>

<pre><code>For audio, there's a hard limit of 32 active AudioTrack objects per device (not per app: you need to share those 32 with rest of the system)
</code></pre>

<p>也就是说音效要共享32个AudioTrack对象。如果超过了32个，是不是就出现声音消失了呢？于是想到对游戏内那些已经播放完毕的音效做处理，卸载掉。</p>

<p>问题果然得到解决！</p>

<p><strong>实际上问题还存在！</strong></p>

<p>但是在经过一系列测试之后发现，这样并没有根本解决问题。声音消失还是会发生，只是不再频繁发生。<br />
所以还需继续挖掘！</p>

<p>我们定位到音效的播放导致的问题，因此<code>Cocos2dxSound</code>出问题的嫌疑最大。它内部调用了<code>SoundPool</code>播放音效。而<code>SoundPool</code>自身就有一个问题。它的构造函数maxStream限制了一次最多播放多少个音效。超过这个上限，有可能播放不出来，也有可能按照优先级将前面播放的音效释放掉而优先播放当前音效。<br />
<code>playEffect</code>函数，会返回的就是steamId，经过测试这个steamId是从1开始递增。<br />
经过测试，steamId如果超过一定数值，也会导致声音播放不出来。</p>

<p>所以鉴于以上的测试，我们对声音的播放进行了优化，同时播放音效控制在10个以内。音效可以循环播放，不必每次都调用<code>playEffect</code>（这可能会影响一些用户体验）。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何使用tableView制作一个高度可以变化的列表]]></title>
    <link href="http://www.newtomato.me/blog/2018/05/13/tableviewcelldong-tai-kuan-gao"/>
    <updated>2018-05-13T16:46:54+08:00</updated>
    <id>http://www.newtomato.me/blog/2018/05/13/tableviewcelldong-tai-kuan-gao</id>
    <content type="html"><![CDATA[<h2 id="section">前面的话</h2>

<p>cocos引擎中提供的CCTableView组件，这个组件由于使用缓存池，创建可见对象，因此性能上相比后来的ListView高出很多。因此在做列表的时候，我一直偏向于使用TableView，但是在一次讨论中发现他有一个缺点就是只能创建cell宽高一致的列表。对于变化的cell则支持不那么友好。</p>

<p>于是抽时间看了一下TableView的实现。就有了几天的这篇分享。<br />
今天我要分享的主题就是如何使用TableView制作一个TablewCell高度变化的列表。<br />
闲话不多说，直接进入正题吧。<br />
<!--more--></p>

<h2 id="section-1">正题</h2>

<p>列表是有很多Cell组成，一般情况下Cell都是相同的显示对象。例如你手机里面的通讯录。或者微信里面好友列表。但是也会有Cell高度不一样的列表。例如微信的朋友圈。他也是TableView，不是cocos的，应该是OC的，或者是swift。但是每个Cell会根据内容自动适配宽高。然后影响列表。</p>

<p>cocos的TableView也可以实现这个效果。而且不需要修改c++的任何代码。听我道来。<br />
从TableView的代码我们可知，他能做到快速滑动是因为它将所有cell的位置先计算出来。在滑动的时候，根据位置计算index然后获取数据，渲染这个cell。<br />
而计算位置，是根据每一个cell的index外加这个cell的宽高。<br />
这些规则并未限制，cell的宽高一定要相同。</p>

<p>在创建Cell的时候，TableView会提前向我们询问这个cell的宽高。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">tableView:registerScriptHandler(handler(self,self.onCellSizeForTable),cc.TABLECELL_SIZE_FOR_INDEX)</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>因此我们要做的就是在内容尚未确定的情况下就要计算出宽高，然后传递给TableView。<br />
就是这个样子。现在让我们看看，这样的TableView能做出的效果。</p>

<p><img src="http://7xuepc.com1.z0.glb.clouddn.com/2018-05-13-tableview_different_height2.gif" alt="tableview_different_height2" /></p>

<p>好像还可以，并且触摸事件也不受一点影响。</p>

<p>实际上计算出宽高的方法并不复杂。从性能角度考虑可能会有一些浪费。具体需要根据情况来判断。<br />
cell计算宽高，可以根据每个元素动态计算宽高。从上面gif中变化的是文本内容。我们只需要根据文本的变化，然后加上图片的宽高就可以计算出来cell最终的高度。<br />
而文本框的宽高和字体，确切说渲染文本框的引擎相关。我们仅需要接触引擎帮我们渲染一次文本，但是并不把他添加到舞台上。渲染结束之后直接就能拿到宽高。内存即可回收。</p>

<p>代码如下：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class=""><span class="line">local text = cc.LabelTTF:create("",fontName, fontSize)
</span><span class="line">text:setDimensions(cc.size(400,0)) --400是我这里设计的要求。
</span><span class="line">text:setString(items[i].msg)
</span><span class="line">local size = text:getContentSize()</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>此时的size就是我们要求出来的宽高。剩下的工作就简单了。<br />
接下来，可以看看我们动态增加cell之后的效果吧。<br />
<img src="http://7xuepc.com1.z0.glb.clouddn.com/2018-05-13-tableview_different_height3.gif" alt="tableview_different_height3" /></p>

<p>使用<code>insertCellAtIndex</code>函数，外加<code>setContentOffset</code>即可实现上述效果。</p>

<h2 id="section-2">结语</h2>

<p>分享到这结束，我提供的是一种思路。里面还涉及一些cell元件的位置动态计算。比较细节，就没有特意说明。如果大家有更好的方法，还希望多多交流！</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[补充在android如何使用dumpsys导出FPS]]></title>
    <link href="http://www.newtomato.me/blog/2018/05/07/androidshi-yong-dumpsysdao-chu-fps"/>
    <updated>2018-05-07T13:14:08+08:00</updated>
    <id>http://www.newtomato.me/blog/2018/05/07/androidshi-yong-dumpsysdao-chu-fps</id>
    <content type="html"><![CDATA[<p>前几日在网上看到一则怎么在android上测试fps的方法。 <a href="https://blog.csdn.net/wpyily/article/details/52593826">链接在此</a>。</p>

<p>文章提到的第三种方式，非常实用。通过<code>dumpsys</code>记录fps日志，然后通过脚本对日志分析，形成直观的图表。<br />
于是尝试搭建这个工具的环境。<br />
工具链接<a href="https://pan.baidu.com/s/13d7OQEMSQIh4fgq6KbE6TA">在此</a>，此处非常感谢<code>sandman</code>的无私付出。</p>

<!--more-->

<h2 id="section">具体使用方法：</h2>

<ol>
  <li>工具有一个<strong>执行说明.txt</strong>,按照他的指示，将busybox和fps.sh放入到手机里面。</li>
  <li>然后执行命令将fps日志保存到check.csv中。</li>
  <li>最后是将日志取出来。adb pull /sdcard/check.csv . (我这里将check.csv最好放在FPS_Test_1.6(刚刚解压缩出来的文件夹)同一级父目录下面。)</li>
  <li>执行如下命令 python FPS_Test_1.6/FPStoHTML.py check.csv</li>
  <li>最终生成了check文件夹。里面head中的data.js便是我们的fps真正的数据所在。</li>
  <li>运行FPS_result.html即可。</li>
  <li>我的运行环境是: Mac Python 2.7.10</li>
</ol>

<p>效果图：<br />
<img src="http://7xuepc.com1.z0.glb.clouddn.com/2018-05-07-15256696433353.jpg" alt="" /></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[大富翁项目总结]]></title>
    <link href="http://www.newtomato.me/blog/2018/03/09/2017xiang-mu-zong-jie"/>
    <updated>2018-03-09T17:53:10+08:00</updated>
    <id>http://www.newtomato.me/blog/2018/03/09/2017xiang-mu-zong-jie</id>
    <content type="html"><![CDATA[<p>年前1月份我们上线了一款大富翁游戏。他的玩法是传统的大富翁玩法+实时多人在线+陌生人匹配。这款游戏从立项到上线，设计思路变化过一次。小变化无数。历时半年左右。虽未取得大成功。但是对于我们团队而言，是一次很好的磨合历练。</p>

<p>之所以采用实时socket连接，就是希望玩家能够真实的感受有人在和他一起玩。希望通过玩家产生内容。增加黏性。提到socket实时游戏，常见的比如魔兽世界，王者荣耀以及绝地求生等（他们使用的实时技术是帧同步或者状态同步，均比我们自己项目中的同步要复杂的多，大富翁的规则是每个回合只有一个人才能够摇筛子，因此需要数据量相对轻量级）。如果大家怎么更好的实时同步感兴趣，建议去腾讯学院查找些干货，这里就不展开说了。</p>

<p>我这里主要总结项目的架构和遇到的问题。<br />
<!--more--></p>

<h2 id="section">概要介绍</h2>

<p>大富翁有很多系统杂糅一起。基础系统是土地买卖，更新归属权。玩家金钱，玩家状态变化。其他系统，股票系统，神仙系统，新闻命运等道路事件系统都是通过影响基础系统来增加玩法的趣味性。所以当玩家摇筛子走到一块没有任何归属土地的时候，需要判断很多情况。</p>

<ul>
  <li>是否有足够的金币。有，准备数据告诉服务器可以购买。（A数据包）</li>
  <li>否，是否有土地公。有，准备数据告诉服务器，我有土地公加成。（A数据包）</li>
  <li>有无恶狗等土地事件。有，准备数据，告诉服务器，恶狗附身。（B数据包）</li>
</ul>

<p>上述简单分析，也就是在这个WaitHere的逻辑中，我们需要调用Player模块，神仙模块，以及道路事件模块，最终将分析出的结果A，B包发给服务器。</p>

<p>在我们的逻辑中，数据模块是耦合在一起的（数据模块自身有对应的接口测试）。而对应逻辑模块自身会通过我们下面提到的自动化测试来验证正确性。</p>

<p>使用的模式有，观察者模式，代理模式，单例模式，状态模式等。使用MVC的思想对业务进行分离。</p>

<h2 id="section-1">请求响应同步模块</h2>

<p>把大富翁的客户端看成一个黑盒子，只有输入输出的话。输出是发出去的请求Request。输入是来自服务器的响应Response。</p>

<p>输出是将玩家的操作整理成请求数据。这个模块暂称之为<strong>“玩家操作模块”</strong>例如摇筛子，购地，升级，使用卡片等。<strong>“响应模块”</strong>就是处理请求，将“决定之后的结果”同步给所有玩家。摇出筛子数字，决定了购地，地块归属发生了变化等。这部分采用状态模式，根据服务器发来的不同状态，进入不同模块，更新数据，更新显示。</p>

<p>这样做的好处在于，数据最终都是以服务器为准。（客户端也会保存一份数据，用于展示。）请求出现问题，在服务器那边会进行校验判定。然后以错误码的形式发送过来。</p>

<p>服务器的响应一个同步队列。比如既能够土地归属发生变化（状态101+数据），又能让神仙附身（状态102+数据）等等。此处便采用状态模式。每种状态处理器各自分开互不影响。状态处理器挨个存到队列中，一个执行结束，执行下一个。知道全都执行结束。然后通知游戏，此次同步结束。解冻“玩家操作模块”，允许玩家继续操作游戏。另外每个状态处理还可以定制自己需要的参数。和服务器开发同学将协议商定下来就行。</p>

<h2 id="section-2">寻路模块</h2>

<p>大富翁类型的地图有自己的特殊性。首先地图有顺时针逆时针的方向要求。有多条主路和部分支路的区分。每条主路会成为一个闭环。玩家不能主动进入支路，只能被动进入。所以对策划同学给的地图我们需要按照顺时针方向制作号码标记。1，2，3，4等。在主路分叉路口上增加协议，例如2_main_1_1,2_main_1_2,2_main_1_3,…主路第一条岔路从主路编号2开始，2_main_2_1，2_main_2_2，2_main_2_3,…这是主路的第二条岔路也是主路编号2开始。说明在主路2号这里有两条岔路。<br />
至于分支，将main改为branch。<br />
按照这样的协议，就可以通过深度优先算法，求算出一条主路的路径。<br />
<img src="http://7xuepc.com1.z0.glb.clouddn.com/2018-03-09-15201639745417.jpg" alt="=w300" /></p>

<h2 id="section-3">断线重连模块</h2>

<p>由于网络环境的问题，游戏会经常断线。但是实际房间并未销毁。所以当玩家重新进入游戏。理论上应该可以重新加入游戏。<br />
此时最大的问题，就是玩家进入游戏需要初始游戏，但是此刻服务器有可能已经开始又数据发送多个更新包过来。所以此刻并不能够立马开始更新游戏。因此这些数据先暂存起来等待初始化完成在更新游戏。</p>

<p>这样数据不会丢失。但是如果缓存的数据过多，又会在更新的时候，造成播放时间较长。伤害了用户体验。因此这里可以将缓存数据做“压缩”处理。直接整合数据，将最后结果更新出来就行，而不用挨个更新。</p>

<p>断线重连遇到一个棘手的问题:<br />
玩家ABCD正处于某一个第三方模块中。模块的初始化时机在进入模块开始。离开模块的时候做清理操作。<br />
此时，某个玩家C突然掉线，待他断线重进的时候，这个第三方模块并未结束。但是服务器不在派发C的进入通知，导致C客户端并不会初始化模块的事件监听。于是游戏模块内做的数据更新通知，在C断线重连之后都不会再做。导致C的数据和其他玩家数据不一致。<br />
为此，只能讲第三方模块所需要用到的初始化都放在主模块中。</p>

<h2 id="section-4">自动测试模块</h2>

<p>这里的自动测试是通过对输入模块进行封装。原先由于用户决定的点击转成系统随机选择。<br />
对任何地块，均可有对应的决策。例如：<br />
	空地。他的决策是是否购地。<br />
	不是自己的土地，但是有归属，则决策是缴纳过路费。<br />
	是自己的土地，决策就是是否升级。<br />
	是自己的研究所，决策是是否要开始研究卡片。<br />
	不是自己的土地，但是身上有土地公。决策就是先付过路费，在占领别人的土地。<br />
以上的例子，均可证明自动测试中，决策可以有系统来做。一旦明确如此，就可以配置测试。</p>

<p>所以流程就是：摇筛子，寻目标地，然后进行决策。更新结果，继续摇筛子，如此循环往复。<br />
这种方式帮助我们测试功能模块是否正确。也节省了大量的测试工作。</p>

<h2 id="section-5">遇到的问题</h2>

<p>大富翁看似简单，实际上在开发中，我们遇到了不少问题。举几个例子：</p>

<ul>
  <li>玩家状态切换，在线和离线状态切换。</li>
  <li>控制权切换，以及在A控制关卡的同时，使用了陷害卡导致B触发了被动卡操作，A的操作倒计时停止，且不能操作关卡，B开始操作倒计时。直到B选择了结果，A的操作倒计时才继续。</li>
  <li>玩家断线重连。这里包括玩家自己杀死游戏重新进入。也包括玩家压入后台，在进入游戏之后，游戏session失效，重新自动登录。两种情况不同在于，第一种是开启了新的游戏进程。第二种是在当前游戏进程，需要清空数据和事件。</li>
  <li>闭包函数当中的upvalue属性要注意。</li>
  <li>场景资源在制作的时候，关卡宽高大约4000x3000，如果使用RGBA8888加载，大约内存会暴涨48M以上。为了能够在低端机上加载进来。所以裁成4张图，逐帧加载。采用pvr(ios)和pkm(android)来分别加载。会有明显改观。</li>
  <li>背景静态图片会带来内存带来压力。而建筑和玩家形象。使用骨骼动画制作，他们带来CPU的压力。初期测试，fps均值在30以上。但是卡顿的感受也存在。为此将建筑替换成序列帧动画。但是为此增加了包体。同屏的顶点数和drawcall有降低。</li>
  <li>美术资源维护出现问题，造成cocos动画工程丢失。只剩下导出文件。为此专门写了一个工具。用于将cocos工程还原。并支持序列帧的导出（部分导出有bug，以后改进。）。但是只能在手机上运行。电脑上总是出现黑边。使用的cocos3.6版本。未深入研究原因。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Unity Shader基础函数：TRANSFORM_TEX]]></title>
    <link href="http://www.newtomato.me/blog/2018/02/11/unity-transform-tex"/>
    <updated>2018-02-11T00:30:09+08:00</updated>
    <id>http://www.newtomato.me/blog/2018/02/11/unity-transform-tex</id>
    <content type="html"><![CDATA[<p>我们知道在unity中tiling和offset是用来设置纹理的重复，也就是俗称的贴瓷砖。<br />
只要我们将tiling设置为（2，2）那么效果如下：<br />
<img src="http://7xuepc.com1.z0.glb.clouddn.com/2018-02-07-15180039093865.jpg" alt="=w300" /></p>

<p>此时，对这个GameObject添加shader，正确读取具体的uv坐标就要用到<code>TRANSFORM_TEX</code>函数。<br />
（如果纹理的tiling=1，offset=1的情况下，可以不使用这个函数）</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">#define TRANSFORM_TEX(tex,name) (tex.xy * name##_ST.xy + name##_ST.zw)</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>语法问题，不是我们的重点。大家可以自行搜索。<br />
这个函数的意思就是对<strong>texture的uv坐标进行一个缩放操作和位移操作</strong>。<br />
那么<code>tex.xy</code>作为关键的参数，他的范围是多少，这个公式操作之后，生成的uv范围又是多少？</p>

<!--more-->

<p>在Shader中通过对顶点函数的修改：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
</pre></td><td class="code"><pre><code class=""><span class="line">v2f vert(a2v v) {
</span><span class="line">	v2f o;
</span><span class="line">	o.pos = UnityObjectToClipPos(v.vertex);
</span><span class="line">	
</span><span class="line">	o.worldNormal = UnityObjectToWorldNormal(v.normal);
</span><span class="line">	
</span><span class="line">	o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;
</span><span class="line">
</span><span class="line">	//o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);
</span><span class="line">	//无论外面的tiling和offset怎么修改，这里一直就是v.texcoord
</span><span class="line">	o.uv = v.texcoord;
</span><span class="line">	
</span><span class="line">	return o;
</span><span class="line">}</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>此时发现，外面的渲染并没有出问题。表现就是tiling(1,1),offset(0,0)的样子。因此可以得知，<code>v.texcoord</code>的u，v范围均是（0，1）<br />
那么通过公式可以推算，如果tiling是（2，2）,计算出来的uv的范围就是（0，2），如此超过了纹理的坐标范围，拿不到纹理才对，怎么实现的贴图？</p>

<p>如果你和我有同样的困惑，那么希望我的回答能让你茅塞顿开！</p>

<p>答案就是纹理设置了贴图方式，这种方式使用opengl的<code>glTexParameteri</code>函数进行设置。(只看opengl，D3D原理相似)</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
</span><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>如果纹理坐标超过（0，1）范围，则开始从头开始寻址。也就是说原先纹理坐标是(0，0.5),此时经过放大2倍，变成（0，1），那么重新开始读取纹理的（0，0）位置。<br />
至此重复贴出的效果就实现了。</p>

<p>另外在unity中纹理贴图方式是在如下位置设置的：<br />
<img src="http://7xuepc.com1.z0.glb.clouddn.com/2018-02-07-15180058478883.jpg" alt="=w300" /></p>

<p>如果你把Wrap Mode设置为<code>Clamp</code>，纹理寻址找不到直接就不显示了。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UI测试AI遇到的问题-尚未解决的难题]]></title>
    <link href="http://www.newtomato.me/blog/2018/02/11/ui-ai"/>
    <updated>2018-02-11T00:15:49+08:00</updated>
    <id>http://www.newtomato.me/blog/2018/02/11/ui-ai</id>
    <content type="html"><![CDATA[<p><img src="http://7xuepc.com1.z0.glb.clouddn.com/2018-02-11-15182797972761.jpg" alt="=w200" /><br />
一直以来，有个想法，希望能够将开发测试工作变得简单。通过简单配置，达到对功能一键测试的目的。<br />
这种测试不是常说的接口测试，而是UI触发测试。</p>

<h2 id="section">场景描述</h2>

<pre><code>例如:
比如说，邮箱系统，领取奖励功能。点击邮箱-&gt;弹开界面-&gt;随机选择一个（可能涉及列表滑动）或者
选择全部领取-&gt;领取成功之后，界面刷新达到的效果是数据正确，界面正确。
一个完整的领取邮箱奖励功能。
</code></pre>

<p>尤其是配置测试部分，做到类似流程图那样的效果。整个流程走完，就能看到直观的看到效果。</p>

<p>但是调研发现，实现起来非常复杂。<br />
<!--more--></p>

<h2 id="section-1">一定要解决的问题</h2>

<ul>
  <li>首先，什么样子的效果才是想要的正确效果？如果不需要人为参与进来，就意味着这套“测试AI”可以自己检验正确性。所以怎么才是正确的？我们需要告诉“测试AI”</li>
  <li>其次，数据太依赖于服务器，如果我们希望能够邮箱中有道具，就需要服务器发送的数据是正确且能够领取的。这样更加不确定正确的结果是什么样子了。</li>
  <li>第三，按照这个流程，如果中间突然弹开新的面板，改如何处理？测试流程应该会卡住。但是某些意外界面弹开，这个“测试AI”是否要继续执行？</li>
  <li>第四，由于“测试AI”只负责点击。点击之间只会有等待时间。那么等待时间设置多少比较合适？等待时间短了，会造成触发了后面的点击，等待时间长了，又会浪费时间。</li>
  <li>第五，UI变化迭代是最频繁的，这套“测试AI”能否智能的识别应该点击何处呢？</li>
</ul>

<p>以上问题，如果无法解决，那么“测试AI”就是空中楼阁。解决的不充分，就会成为鸡肋，事倍功半。</p>

<p>以下是我想到的方案，遗憾的是，都没有解决到上面的问题。<br />
我写下来是想要将自己的思路整理一下，同时希望能有志同道合的人帮忙指点一二。<br />
如果你看到此处，很失望的话。可以不必再往下继续了。</p>

<h2 id="section-2">方案列举</h2>

<p>首先想到的方案，是在将点击的面板和控件都写在配置文件中。通过定时器，每隔一定时间触发。但是定时器的触发有偏差，会造成时间到了，应该弹开的界面没有弹开。后续操作全作废。<br />
第二想方案，是通过<code>adb shell sendevent</code>外加截屏的方法，这样从代码层分离，对任何项目能用。通过截屏图片分析是否是正确的结果。但是sendevent的位置依赖UI，UI一旦变化，位置都要调整。<br />
第三方案，游戏客户端socket连接到“测试AI”的服务器上，将UI界面上所有的空间dump给服务器。这样服务器能够知道所有UI控件的数据，自然有位置信息。然后按照“测试配置”触发。</p>

<p>第三种方案已经是我想到最合适的一种。但是仍然苦于对于等待时间的设定。尤其某些一定要等待服务器请求回来之后的（这样便依赖于网络情况）。如果让业务层面通知“测试AI”可以继续，则会增加开发的工作量。</p>

<p>使用过网易开发的ATX自动化测试。鉴于他是需要通过截图来实现游戏的测试。有些依赖UI，截图也非常不方便。同时第四条的问题也没有解决。</p>

<p>目前为止，尚未找到合适的方法。</p>

<p>这个想法在我脑海中已经盘桓很久。以前的一个项目实现过一个自动化测试，完全是基于业务层面。从游戏启动到进入关卡战斗，以及战斗播放结果。回到关卡界面，继续选择，在进入关卡，如此循环。这一些都是强制和业务代码写在一起。虽然达到了游戏自动测试关卡的目的，但是不能抽象出来供其他项目使用，总觉得很是遗憾。</p>

<p>总之，该用什么方法好呢？</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[opengl基础之glDrawArrays和glDrawElements之间的区别]]></title>
    <link href="http://www.newtomato.me/blog/2018/01/29/openglgldrawarrays"/>
    <updated>2018-01-29T10:12:07+08:00</updated>
    <id>http://www.newtomato.me/blog/2018/01/29/openglgldrawarrays</id>
    <content type="html"><![CDATA[<p>我们首先来绘制一个矩形。矩形的顶点数据和材质数据如下：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class=""><span class="line">GLfloat vertices[] = {
</span><span class="line">				0.0f,0.0f,0.0f,0.0f,0.0f,
</span><span class="line">				0.5f,0.0f,0.0f,0.5f,0.0f,
</span><span class="line">				0.5f,0.5f,0.0f,0.5f,0.5f,
</span><span class="line">				0.0f,0.5f,0.0f,0.0f,0.5f
</span><span class="line">				};</span></code></pre></td></tr></table></div></figure></notextile></div>
<!--more-->
<p>前三位是顶点位置信息，后两位是纹理坐标位置。<br />
此时我们如果绘制矩形，使用如下命令：<code>glDrawArrays(GL_TRIANGLE_STRIP,0,5);</code><br />
这里我使用的是<code>GL_TRIANGLE_STRIP</code>模式，这种模式的是<strong>每相邻三个顶点组成一个三角形</strong>。因此我提供四个点即可。<br />
如果是<code>GL_TRIANGLES</code>,仅仅提供四个点，就只能绘制出一个三角形。所以需要对vertices进行扩展，提供6个点的位置。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class=""><span class="line">GLfloat vertices2[] = {
</span><span class="line">				0.0f,0.0f,0.0f,0.0f,0.0f,
</span><span class="line">				0.5f,0.0f,0.0f,0.5f,0.0f,
</span><span class="line">				0.0f,0.5f,0.0f,0.0f,0.5f,
</span><span class="line">				0.5f,0.0f,0.0f,0.5f,0.0f,
</span><span class="line">				0.0f,0.5f,0.0f,0.0f,0.5f,
</span><span class="line">				0.5f,0.5f,0.0f,0.5f,0.5f
</span><span class="line">				};</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>但是，这样你会看到数据变多了，实际就是点重复了。<br />
那么怎么解决数据冗余的问题呢？如果每个点的数据知道，绘制三角形的时候，告诉他取那个位置的点就好了。<code>glDrawElements</code>就是这么解决问题的！<br />
有了vertices数据之后，我们还需要提供一个索引数据。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class=""><span class="line">GLuint indices[] = { 
</span><span class="line">    0, 1, 3,
</span><span class="line">    1, 2, 3 
</span><span class="line">};</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>在现代opengl编程中，需要将索引数据绑定到<code>GL_ELEMENT_ARRAY_BUFFER</code></p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class=""><span class="line">Gluint EBO;
</span><span class="line">glGenBuffers(1, &amp;EBO); 
</span><span class="line">glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);
</span><span class="line">glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);
</span><span class="line">
</span><span class="line">...
</span><span class="line">//绘制三角形，6个顶点，使用索引数据。数据的类型是GL_UNSIGNED_INT。
</span><span class="line">glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);
</span></code></pre></td></tr></table></div></figure></notextile></div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OpenGL基础之普通光照]]></title>
    <link href="http://www.newtomato.me/blog/2018/01/07/openglji-chu-zhi-pu-tong-guang-zhao"/>
    <updated>2018-01-07T18:33:45+08:00</updated>
    <id>http://www.newtomato.me/blog/2018/01/07/openglji-chu-zhi-pu-tong-guang-zhao</id>
    <content type="html"><![CDATA[<p>opengl中有三种光照，环境光，漫反射以及镜面光源。<br />
不同物体可以通过的材质（Material）对光照的参数的设置能够达到模拟真实的效果。</p>

<p>三种光照的基本知识，推导公式，以及Material是干什么用的均在<strong>learnopengl</strong>的教程中已经有详细的介绍，我将在这篇博文里面将按照自己的理解整理一下，也好加深自己的理解。</p>

<p>光照对物体的影响是通过他对物体颜色变量的加成而达到效果的。也就是说光照并没有带来新的元素，只是影响了颜色。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">object_color = new_light_color * object_color</span></code></pre></td></tr></table></div></figure></notextile></div>

<!--more-->
<p>对环境光而言，因为大家都收到这个光照的影响。所以环境光ambient是一个常量。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">new_light_color = ambient * light_color * 特殊材质变量</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>对漫反射而言，需要参考下面的图计算发射之后颜色。<br />
<img src="http://7xuepc.com1.z0.glb.clouddn.com/2018-01-07-15153188795257.jpg" alt="" /><br />
光源的位置<code>light_pos</code>以及当前照射那点的法线向量<code>N</code>（此法线在顶点数据中已经设定好了，一般是出模型Mesh的时候已经包含了进来），他们之间的角度决定这一点的亮度，角度越小，光照越垂直于此点。所以求两个向量之间的夹角。使用向量的点乘。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class=""><span class="line">vec3 light_dir = light_pos - frag_pos
</span><span class="line">float diff = max(dot(norm, light_dir), 0.0);
</span><span class="line">vec3 new_light_color = diff * light_color * 特殊材质漫反射变量</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>对于镜面反射而言，和漫反射不同的时候，不仅仅有光源和法线还需要有观察者的位置。因为镜面反射对观察者有影响。观察者位置不同看到的镜面反射也不同。<br />
<img src="http://7xuepc.com1.z0.glb.clouddn.com/2018-01-07-15153193377520.jpg" alt="" /></p>

<p>镜面反射求的是反射光线对观察者的影响，因此就是观察者向量在反射光线向量上的投影。也就是这两个向量之间的夹角。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class=""><span class="line">vec3 eye_dir = normalize(eye_pos - FragPos);
</span><span class="line">//此处注意，为了便于理解，我这里的light_dir向量方向是从光源到点的方向。因为reflect函数，第一个参数要求就是光源到点的方向。教程中使用的-lightDir，是因为lightDir是从点到光源。
</span><span class="line">vec3 reflectDir = reflect(light_dir, norm);
</span><span class="line">float spec = pow(max(dot(reflectDir,eye_dir),0),特殊材质反光度变量)
</span><span class="line">vec3 new_light_color = spec * light_color * 特殊材质镜面光变量
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>上面三种光照，会产生新的<code>new_light_color</code>，此时全部都作用到object身上就是</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">vec3 result = (ambient(环境光) + diffuse（漫反射光） + specular（镜面光）) * objectColor;
</span><span class="line">FragColor = vec4(result, 1.0);</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>上面每个光照的公式中均有一个特殊材质变量，这些变量就是材质Material的控制变量。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class=""><span class="line">struct Material {
</span><span class="line">    vec3 ambient;
</span><span class="line">    vec3 diffuse;
</span><span class="line">    vec3 specular;
</span><span class="line">    float shininess;
</span><span class="line">}; 
</span><span class="line">
</span><span class="line">uniform Material material;</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>通过对三种光照公式的分析，抽取除了材质这样的数据结构。所以在游戏引擎中，我们只要对object选择不同材质，光照就会发生变化，原因仅在于此。<br />
另外上面还有一个很重要的点需要提出来说一下，就是在计算向量加减的时候，使用的是世界坐标系。<br />
尤其是在计算法线向量的转换的时候，我们需要将法线向量从模型坐标系转为世界坐标系。使用专门的法线矩阵。也就是模型矩阵左上角3x3矩阵的逆矩阵的转置矩阵。非常拗口的概念。<br />
对应opengl函数就是<code>normal = mat3(transpose(inverse(model))) * aNormal</code>;<br />
不对法线向量进行坐标转换，则会导致上面向量不在同一个坐标系，因而加减会出现问题。<br />
如果不是世界坐标系，是观察者坐标系，则需要将里面的<code>model</code>变为<code>view*mode</code>。</p>

<p>这里分享的是光照的基础知识，还有光照引申出来的不同灯光效果，光照贴图将放到下一章节总结。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OpenGL基础之常用调用接口]]></title>
    <link href="http://www.newtomato.me/blog/2018/01/07/openglji-chu-zhi-chang-yong-diao-yong-jie-kou"/>
    <updated>2018-01-07T17:13:16+08:00</updated>
    <id>http://www.newtomato.me/blog/2018/01/07/openglji-chu-zhi-chang-yong-diao-yong-jie-kou</id>
    <content type="html"><![CDATA[<p>学习opengl的时候，我们经常用到的函数大致有如下几个，这些函数之间奇怪的命名方式一开始总让我们摸不着头脑。例如<code>glGenVertexArrays</code>之后，怎么传递了数据，怎么使用了这些数据？</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class=""><span class="line">glGenVertexArrays(1, &amp;VAO)
</span><span class="line">glGenBuffers(1, &amp;VBO);
</span><span class="line">glBindVertexArray(VAO);
</span><span class="line">glBindBuffer(GL_ARRAY_BUFFER, VBO);
</span><span class="line">glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);
</span><span class="line">glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(GLfloat), (GLvoid*)0);
</span><span class="line">glDrawArrays(GL_TRIANGLES, 0, 36);</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>今天我们就梳理一下这些函数的含义。从我理解的角度讲解一下，增加大家对他的印象。<br />
<!--more--></p>

<p>首先opengl的函数都从<code>glGen*(GLsizei n​, GLuint *objects​)</code>的函数开始，这个函数创建了一个opengl对象，第二个参数就是这个对象的引用。<br />
对象创建结束之后，还需要给他数据，并且告诉他这个数据的结构。例如我们上面创建的<code>VBO</code>。<br />
<code>VBO(vertical buffer object)</code>是顶点数据，创建<code>glGenBuffers</code>和激活<code>glBindBuffer</code>之后，我们就可以传递数据<code>(glBufferData)</code>，同时对这个数据进行结构说明<code>(glVertexAttribPointer)指针从哪里开始，步长多少，获取多少数据等</code>。<br />
这样我们的顶点缓冲数据都会存在VBO这个引用中。<br />
顶点缓冲数据如此，纹理也是如此，创建<code>glGenTextures</code>，激活<code>glBindTexture</code>以及数据传递<code>glTexImage2D</code>。</p>

<p>经过这些函数数据设置OK，然后调用<code>glDrawArrays</code>，就可以将图像的骨和皮画出来。</p>

<p>接下来说细节，纹理相对简单一些放在后面，顶点数据既然有了<code>VBO</code>，为什么要使用<code>VAO（Vertex Array Object）</code>呢？因为一般情况下，一个显示物体不仅仅有一个或者一种VBO，还有有<code>EBO（他另一个名字是IBO）</code>。因此开发者考虑能不能将一个物体用到的所有缓冲对象都包裹在一切，用到的时候，直接这一个用。因此他们就开发出了<code>VAO</code>。</p>

<p>VAO创建了之后，不需要给他任何数据，只要在激活他之后，对VBO操作就可以了，opengl内部会自动将这个VBO绑定到VAO上面。只需要操作这个VAO就可以了。这段话的意思并不是说VAO可以脱离VBO，而是说创建多个VBO之后，如果挂靠在一个VAO上会更容易管理。如果没有<code>VBO</code>，VAO则没有任何用处。</p>

<p>例如在漫反射贴图的opengl教程中，有下面一段代码：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
</pre></td><td class="code"><pre><code class=""><span class="line">// 顶点输入
</span><span class="line">GLfloat vertices[] = {
</span><span class="line">		// 顶点             // 法线              // 纹理坐标
</span><span class="line">		-0.5f, -0.5f, -0.5f,  0.0f,  0.0f, -1.0f,  0.0f,  0.0f,
</span><span class="line">		.....
</span><span class="line">}；
</span><span class="line">
</span><span class="line">//--------------设置containerVAO开始--------------------------
</span><span class="line">GLuint VBO, containerVAO;
</span><span class="line">glGenVertexArrays(1, &amp;containerVAO);
</span><span class="line">glGenBuffers(1, &amp;VBO);
</span><span class="line">
</span><span class="line">// 把顶点数组复制到缓冲中供OpenGL使用
</span><span class="line">glBindBuffer(GL_ARRAY_BUFFER, VBO);
</span><span class="line">glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);
</span><span class="line">// !!! Bind the Vertex Array Object first, then bind and set vertex buffer(s) and attribute pointer(s).
</span><span class="line">glBindVertexArray(containerVAO);
</span><span class="line">glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(GLfloat), (GLvoid*)0);
</span><span class="line">glEnableVertexAttribArray(0);
</span><span class="line">glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(GLfloat), (GLvoid*)(3 * sizeof(GLfloat)));
</span><span class="line">glEnableVertexAttribArray(1);
</span><span class="line">glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(GLfloat), (GLvoid*)(6 * sizeof(GLfloat)));
</span><span class="line">glEnableVertexAttribArray(2);
</span><span class="line">glBindVertexArray(0);
</span><span class="line">//--------------设置containerVAO结束--------------------------
</span><span class="line">
</span><span class="line">
</span><span class="line">//--------------设置lightVAO开始------------------------------
</span><span class="line">// 设置光照的顶点数组对象(VAO)，顶点缓冲对象(VBO)共用
</span><span class="line">GLuint lightVAO;
</span><span class="line">glGenVertexArrays(1, &amp;lightVAO);
</span><span class="line">glBindVertexArray(lightVAO);
</span><span class="line">// 只需要绑定VBO不用再次设置VBO的数据，因为容器(物体)的VBO数据中已经包含了正确的立方体顶点数据
</span><span class="line">glBindBuffer(GL_ARRAY_BUFFER, VBO);
</span><span class="line">// 设置灯立方体的顶点属性指针(仅设置灯的顶点数据)
</span><span class="line">glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(GLfloat), (GLvoid*)0); // Note that we skip over the other data in our buffer object (we don't need the normals/textures, only positions).
</span><span class="line">glEnableVertexAttribArray(0);
</span><span class="line">glBindVertexArray(0);
</span><span class="line">//--------------设置lightVAO结束------------------------------
</span><span class="line">// 读取贴图
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>我们并没有给VAO数据，<code>glBufferData</code>之后数据还是在VBO中，所以VAO只是包裹了这个VBO。<br />
上面对opengl所需要的数据先做处理，这些是静态数据不会发生变化，会变化的的数据则放在了下面while循环里面。下面我们对while循环函数进行分析。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
</pre></td><td class="code"><pre><code class=""><span class="line">...
</span><span class="line">// 渲染指令
</span><span class="line">glClearColor(0.1f, 0.1f, 0.1f, 1.0f);
</span><span class="line">glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
</span><span class="line">
</span><span class="line">....
</span><span class="line">箱子使用的shader进行参数get和set。
</span><span class="line">....
</span><span class="line">
</span><span class="line">// 激活纹理
</span><span class="line">glActiveTexture(GL_TEXTURE0);
</span><span class="line">glBindTexture(GL_TEXTURE_2D, diffuseMap);
</span><span class="line">
</span><span class="line">//使用上面创建的containerVAO对象
</span><span class="line">glBindVertexArray(containerVAO);
</span><span class="line">glDrawArrays(GL_TRIANGLES, 0, 36);
</span><span class="line">glBindVertexArray(0); //清理VAO对象，但不是释放。
</span><span class="line">
</span><span class="line">...
</span><span class="line">灯的shader进行参数get和set。
</span><span class="line">...
</span><span class="line">//激活灯的lightVAO对象。上面已经创建，这里直接使用即可。如果在while循环里面不断创建会浪费内存。
</span><span class="line">glBindVertexArray(lightVAO);
</span><span class="line">glDrawArrays(GL_TRIANGLES, 0, 36);
</span><span class="line">glBindVertexArray(0);
</span><span class="line">
</span><span class="line">// 交换缓冲,一般采用前后双缓冲，这样屏幕变化玩家几乎看不到中间的切换。
</span><span class="line">glfwSwapBuffers(window);
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>上面分析下来，可以看出VAO至少是包裹了VBO，且VBO还可以被重用。箱子和灯都是立方体，所以一份VBO对象给箱子使用也给灯使用。<br />
这样VBO重用减少了内存的开销，VAO则方便了顶点数据的管理。</p>

<p>说完顶点数据相关的VAO，VBO，在来看看纹理。</p>

<p>但上面代码，texture的数据映射关系是在<strong>vertices</strong>中，但是具体的纹理并不受VAO的管理。纹理数据被传递给diffuseMap引用。而diffuseMap虽然在VAO后面，但是没有挂靠于VAO，这些实现全都是OpenGL内部实现的。也就是说VAO只能管理VBO和EBO，其他的依然是自己管理自己。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
</pre></td><td class="code"><pre><code class=""><span class="line">// 读取贴图
</span><span class="line">GLuint diffuseMap;
</span><span class="line">glGenTextures(1, &amp;diffuseMap);
</span><span class="line">//int width, height;
</span><span class="line">unsigned char* image;
</span><span class="line">// 漫反射贴图
</span><span class="line">image = stbi_load("container2.jpg", &amp;width, &amp;height, 0, 0);
</span><span class="line">glBindTexture(GL_TEXTURE_2D, diffuseMap);
</span><span class="line">glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, image);
</span><span class="line">glGenerateMipmap(GL_TEXTURE_2D);
</span><span class="line">stbi_image_free(image);
</span><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
</span><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
</span><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
</span><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST_MIPMAP_NEAREST);
</span><span class="line">glBindTexture(GL_TEXTURE_2D, 0);</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>上面代码创建了diffuseMap引用，读取硬盘上jpg图片，将数据通过glTexImage2D传递给GL_TEXTURE_2D目标，其实GL_TEXTURE_2D目标已经和diffuseMap引用绑定在了一起。所以你可以理解diffuseMap里面有一个GL_TEXTURE_2D目标，我们对GL_TEXTURE_2D进行<code>glTexParameteri</code>设置就是对diffuseMap的设置。<br />
最后，<code>glBindTexture(GL_TEXTURE_2D, 0);</code>并不是释放diffuseMap引用。而是opengl纹理绑定的状态进行了清理。以便于在while循环中重新设置。<br />
这一局不调用也不会出问题，因为下面被重新设置了。不过这样做比较清晰不容易出问题。</p>

<p>while循环中在上面的代码已经有，可在读一遍。</p>

<p>总的来说，opengl看似复杂，实则简单清楚，只要我们对常用的几个函数了熟于心。以此为突破口，就不会被他复杂的表面欺骗。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OpenGL基础之透视投影矩阵]]></title>
    <link href="http://www.newtomato.me/blog/2017/12/16/opengl-tou-shi-tou-ying-ju-zhen"/>
    <updated>2017-12-16T18:12:54+08:00</updated>
    <id>http://www.newtomato.me/blog/2017/12/16/opengl-tou-shi-tou-ying-ju-zhen</id>
    <content type="html"><![CDATA[<p>今天我们来讲解一下怎么推导投影矩阵。投影矩阵的作用是剔除不在锥视体内的坐标，同时将锥视体内的坐标转换为标准化设备坐标。</p>

<p>投影矩阵分为两种，一种是2D常用的正交投影，另外一种就是3D游戏常用的透视投影，透视投影更符合我们对现实世界的模拟。</p>

<p>正如上篇博文说道坐标转换的过程。如下图所示：</p>

<p><img src="http://7xuepc.com1.z0.glb.clouddn.com/2017-12-16-15128199931966.jpg" alt="-" /></p>

<p>而<strong>透视矩阵</strong>是透视除法的核心。<br />
按照 <code>P(NDC) = M(透视矩阵) * P(C)</code>的公式如（图1），就能将裁剪坐标转为规范化坐标。</p>

<!--more-->

<p><img src="http://7xuepc.com1.z0.glb.clouddn.com/2017-12-16-15126253778019_1.jpg" alt="-w150" /><br />
(图1)</p>

<p>带e下标的表示摄像机坐标，即通过<code>模型矩阵*摄像机矩阵*物体本地坐标</code>计算得来的坐标<br />
带c下标的标示剪裁坐标，P是投影矩阵。<br />
带n下标的是设备标准化坐标，标准化坐标的范围在[-1,1]内，所以需要将裁剪坐标归一化处理。<br />
最终根据<code>glViewPort()</code>传递过来的屏幕大小和上面的标准化坐标，便能转换成屏幕标准。</p>

<h3 id="section">透视锥视体</h3>
<p><img src="http://7xuepc.com1.z0.glb.clouddn.com/2017-12-16-15126256321092.jpg" alt="-w300" /><br />
<img src="http://7xuepc.com1.z0.glb.clouddn.com/2017-12-16-15126418783276.jpg" alt="-w300" /><br />
锥视体有<strong>near，far，宽高比以及fov(field of view，可以看成是视角)</strong>来决定箱体的大小。<br />
只要控制任何一个变量，都能让锥视体变化。<br />
上图中，坐标原点假设在（0，0，0）,那么近平面的中心点在(0,0,near),远平面的中心同理在（0，0，far）</p>

<h2 id="section-1">透视矩阵推导</h2>

<p><img src="http://7xuepc.com1.z0.glb.clouddn.com/2017-12-16-15126252106319.jpg" alt="-w350" /><br />
在上图，对near进行划分，l=&gt;left,t=&gt;top,r=&gt;right,b=&gt;bottom。<br />
则如果我们从上面往下看这个锥视体。只有<strong>xz</strong>这个平面。</p>

<p>有三角形相似性，我们得知：<code>Ze/Zp = Xe/Xp</code>。<br />
我们使用的是near平面。所以Zp的大小是near。方向是z负轴，所有<code>Zp=-n</code>，带入到上面公式，<code>Xp = -n* Xe/Ze</code>。如下图所示：<br />
<img src="http://7xuepc.com1.z0.glb.clouddn.com/2017-12-16-15134146322302.png" alt="-w200" /><br />
同理，我们可以求得<code>Yp</code>（从X轴看向去，只有YZ平面）。<br />
<img src="http://7xuepc.com1.z0.glb.clouddn.com/2017-12-16-15134147063339.png" alt="" /><br />
因此将一个点投影到锥视体的近平面的坐标（Xp,Yp,Zp）便计算出来。接下来计算这个P点坐标和规范化设备坐标的转换。P坐标的x,y最终要转换成[-1,1]区间。如下图所示，横轴是以Xp为轴，纵轴是Xn。<br />
<img src="http://7xuepc.com1.z0.glb.clouddn.com/2017-12-16-15134159083184.jpg" alt="-w200" /><br />
因此他们满足的关系是二元一次方程:<code>Xn = k*Xp + b</code></p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class=""><span class="line">1  = k*r + b
</span><span class="line">-1 = k*l + b
</span><span class="line">
</span><span class="line">k = 2/(r -l)
</span><span class="line">b = -k(r+l)/2
</span><span class="line">
</span><span class="line">Xn = 2/(r-l)*Xp - (r+l)/(r-l)</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>同理Yn和Yp之间的关系也是如此。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">Yn = 2/(t-b) * Yp - (t+b)/(t-b)</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>将上面Xp,Yp的公式带入到Xn,Yn中。如果下图所示：<br />
<img src="http://7xuepc.com1.z0.glb.clouddn.com/2017-12-16-15134168329201_2.jpg" alt="-w200" /><img src="http://7xuepc.com1.z0.glb.clouddn.com/2017-12-16-15134168191851_2.jpg" alt="-w200" /><br />
在最上面的公式，我们知道<code>Xn=Xc/Wc</code>,所以设<code>Wc=Ze</code>。推导出矩阵如下：<br />
<img src="http://7xuepc.com1.z0.glb.clouddn.com/2017-12-16-15134170212170.jpg" alt="" /><br />
矩阵中第三行还没有解决。<br />
Z轴的数值转化之后的目的是用来进行clipping和Depth Test。<br />
我们对上面的矩阵进行修改，用来计算Zn和Ze之间的关系。<br />
<img src="http://7xuepc.com1.z0.glb.clouddn.com/2017-12-16-15134174579880.jpg" alt="" /><br />
在摄像机矩阵中We等于1，因此上面公式可以简化。<br />
同时Zp=-near的时候，Zn=-1，Zp=-far的时候，Zn=1。<br />
通过上述条件。我们计算得知：<br />
<img src="http://7xuepc.com1.z0.glb.clouddn.com/2017-12-16-15134176793143.jpg" alt="-w200" /></p>

<p>所以投影矩阵最终的样子如下：</p>

<p><img src="http://7xuepc.com1.z0.glb.clouddn.com/2017-12-16-15134182206777_2.png" alt="" /><br />
由于锥视体都是对称的。因此r和l的值相等。t和b的值相等。上面的公式又可以转化为：<br />
<img src="http://7xuepc.com1.z0.glb.clouddn.com/2017-12-16-15134184015016_2.jpg" alt="" /></p>

<p>到此投影矩阵的推导基本完成。</p>

<p>工作中常用到投影，却很少为此深入了解。知其然最好能知其所以然。为此研读各类资料，在此整理出来，既是对自己的一个总结，也希望借此捋一捋这方面的知识。了解之后，对opengl以及图像学会有不同看问题的角度。如上面有误，还请不吝指出。</p>

<h2 id="section-2">参考文档</h2>

<ol>
  <li><a href="https://www.cnblogs.com/graphics/archive/2012/07/25/2582119.html">透视投影详解</a></li>
  <li><a href="http://www.songho.ca/opengl/gl_projectionmatrix.html">OpenGL Projection Matrix</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OpenGL基础之模板缓存]]></title>
    <link href="http://www.newtomato.me/blog/2017/12/15/openglji-chu-zhi-mo-ban-huan-cun"/>
    <updated>2017-12-15T23:50:52+08:00</updated>
    <id>http://www.newtomato.me/blog/2017/12/15/openglji-chu-zhi-mo-ban-huan-cun</id>
    <content type="html"><![CDATA[<p>一个支持OpenGL绘制的窗口（即一个默认的帧缓存）可以由以下一些组合构成：多达四个颜色缓存,深度缓存,模板缓存,多重采样（MSAA）缓存,辅助缓存。</p>

<p>我们今天主要讨论模板缓存。模版缓冲（STENCIL_BUFFER）通过设置模版缓冲每个像素的值,我们可以指定在渲染的时候只渲染某些像素,从而可以达到一些特殊的效果。</p>

<p>通过对cocos2dx里面遮罩裁剪功能的分析，对模板缓存有个初步认识。<br />
<!--more--></p>

<h2 id="cocos2dx-">cocos2dx 遮罩的实现</h2>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
</pre></td><td class="code"><pre><code class=""><span class="line">local TestClippingScene  = class("TestClippingScene",cc.load("mvc").ViewBase)
</span><span class="line">
</span><span class="line">function TestClippingScene:onCreate(event)
</span><span class="line">	local mask = display.newSprite("MainSceneBg.jpg")
</span><span class="line">	local sencialnode = display.newSprite("BugSpider.png")
</span><span class="line">
</span><span class="line">	local clippingNode = cc.ClippingNode:create(sencialnode)
</span><span class="line">	
</span><span class="line">            -- clippingNode:setInverted(true) --注释1
</span><span class="line">            -- clippingNode:setAlphaThreshold(0)--注释2
</span><span class="line">            clippingNode:addChild(mask)
</span><span class="line">
</span><span class="line">            self:addChild(clippingNode)
</span><span class="line">            clippingNode:setPosition(display.center)
</span><span class="line">            
</span><span class="line">end
</span><span class="line">
</span><span class="line">return TestClippingScene</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>运行上面的代码得到的如下图像。由于没有Alpha测试，导致以图片的矩形为准做遮罩。</p>

<p><img src="http://7xuepc.com1.z0.glb.clouddn.com/2017-12-15-IMG_1426.png" alt="IMG_1426" /><br />
将<strong>注释2</strong>的取消掉。就会如下所示。透明区域不起作用。<br />
<img src="http://7xuepc.com1.z0.glb.clouddn.com/2017-12-15-IMG_1427.png" alt="IMG_1427" /></p>

<p>将<strong>注释1</strong>的取消掉，则得到如下的效果:<br />
<img src="http://7xuepc.com1.z0.glb.clouddn.com/2017-12-15-IMG_1428.png" alt="IMG_1428" /></p>

<p>具体的原理是什么呢？我们需要深入到cocos2dx的源码中。</p>

<h2 id="cocos2dx">cocos2dx中遮罩裁剪的原理</h2>

<h3 id="section">源码阅读</h3>

<p>我们通过阅读ClippingNode.cpp的代码知道，真正实现裁剪的代码是：<code>StencilStateManager::onBeforeVisit()</code></p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
<span class="line-number">40</span>
<span class="line-number">41</span>
<span class="line-number">42</span>
<span class="line-number">43</span>
<span class="line-number">44</span>
<span class="line-number">45</span>
</pre></td><td class="code"><pre><code class=""><span class="line">void StencilStateManager::onBeforeVisit()
</span><span class="line">{
</span><span class="line">	...
</span><span class="line">
</span><span class="line">	glDepthMask(GL_FALSE);
</span><span class="line">	RenderState::StateBlock::_defaultState-&gt;setDepthWrite(false);
</span><span class="line">	
</span><span class="line">	glStencilFunc(GL_NEVER, mask_layer, mask_layer);
</span><span class="line">	//这里的意思是无论什么像素都不会通过模板测试，也就是全部像素都会失败。
</span><span class="line">	glStencilOp(!_inverted ? GL_ZERO : GL_REPLACE, GL_KEEP, GL_KEEP);
</span><span class="line">	//如果不是_inverted模式，模板填充0，如果是则填充mask_layer。
</span><span class="line">	//因为上面失败，所以这里如果是普通遮罩，_inverted为false，则模板缓存里面会全部设置成0。
</span><span class="line">	//那么也就意味着什么都画不上去。
</span><span class="line">	drawFullScreenQuadClearStencil();    
</span><span class="line">	//画一个全屏的矩形，整理模板缓存。上面代码执行之后，模板缓存的样子如(图1)
</span><span class="line">	
</span><span class="line">	glStencilFunc(GL_NEVER, mask_layer, mask_layer);
</span><span class="line">	glStencilOp(!_inverted ? GL_REPLACE : GL_ZERO, GL_KEEP, GL_KEEP);
</span><span class="line">	//如果是普通遮罩，那么像素上面因为失败，这里会全部替换成mask_layer（glStencilFunc的第二个参数）的值。可参考（图2）
</span><span class="line">	
</span><span class="line">	//下面是Alpha Test。
</span><span class="line">	if (_alphaThreshold &lt; 1) {
</span><span class="line">	#if !CC_CLIPPING_NODE_OPENGLES
</span><span class="line">	    _currentAlphaTestEnabled = glIsEnabled(GL_ALPHA_TEST);
</span><span class="line">	    glGetIntegerv(GL_ALPHA_TEST_FUNC, (GLint *)&amp;_currentAlphaTestFunc);
</span><span class="line">	    glGetFloatv(GL_ALPHA_TEST_REF, &amp;_currentAlphaTestRef);
</span><span class="line">	    glEnable(GL_ALPHA_TEST);
</span><span class="line">	    CHECK_GL_ERROR_DEBUG();
</span><span class="line">	    glAlphaFunc(GL_GREATER, _alphaThreshold);
</span><span class="line">	#endif
</span><span class="line">	}
</span><span class="line">}
</span><span class="line">
</span><span class="line">//渲染结束，之后把模板状态还原，_currentStencilFunc值都是在执行visit之前从opengl里面获取的值。
</span><span class="line">void StencilStateManager::onAfterVisit()
</span><span class="line">{
</span><span class="line">    glStencilFunc(_currentStencilFunc, _currentStencilRef, _currentStencilValueMask);
</span><span class="line">    glStencilOp(_currentStencilFail, _currentStencilPassDepthFail, _currentStencilPassDepthPass);
</span><span class="line">    glStencilMask(_currentStencilWriteMask);
</span><span class="line">    if (!_currentStencilEnabled)
</span><span class="line">    {
</span><span class="line">        glDisable(GL_STENCIL_TEST);
</span><span class="line">    }
</span><span class="line">    s_layer--;
</span><span class="line">}</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="section-1">关键函数：</h3>

<ol>
  <li><code>glStencilFunc</code>:用来规定是否通过了 <code>stencil test</code> 的规则。<br />
<code>glStencilFunc</code>的原形是: <code>glStencilFunc( GLenum func, GLint ref, GLuint mask)</code>;<br />
函数意义：指定模板测试比较函数，<strong>模板值</strong>与要写入的<strong>像素值</strong>做与操作，然后得到的结果，用第一个参数指定的函数和第二参数进行比较。如果满足则通过了模板测试。可以写入。否则不满足。</li>
  <li><code>glStencilOp</code>:向<code>stencil buffer</code> 中写内容的规则。<br />
<code>glStencilOp</code>(GLenum fail , GLenum zfail, GLenum zPss );<br />
函数意义：当某些图元在绘制的时候,如果模板测试失败(或者深度测试失败),它怎么修改其打算写入的位置的模板值</li>
</ol>

<p>如果是不调用了<code>setInverted</code>的话。就如下图所示。<br />
(图1)<img src="http://7xuepc.com1.z0.glb.clouddn.com/2017-12-15-1.png" alt="1" />(图2)<img src="http://7xuepc.com1.z0.glb.clouddn.com/2017-12-15-0.png" alt="0" /></p>

<p>调用<code>setInverted(true)</code>则如下图所示：<br />
<img src="http://7xuepc.com1.z0.glb.clouddn.com/2017-12-15-a.png" alt="a" /><img src="http://7xuepc.com1.z0.glb.clouddn.com/2017-12-15-b.png" alt="b" /></p>

<p>鉴于此，我们知道将要draw上去的不会通过模板测试，但是却会将模板留下他的形状（凡是为1的地方才会被绘制）。接下来在绘制其他形状的东西时候。在模板测试这里，直接就会按照模板的样子draw出来。<br />
因此遮罩效果就有了！</p>

<h2 id="section-2">参考文档</h2>

<ol>
  <li><a href="http://www.jianshu.com/p/bed926e53517">OpenGL模板缓存</a></li>
  <li><a href="http://www.lxway.com/929242951.htm">对模板缓存的一些个人理解</a></li>
  <li><a href="http://blog.csdn.net/zenny_chen/article/details/5903925">深入了解OpenGL——帧缓存</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[OpenGL基础之矩阵和坐标]]></title>
    <link href="http://www.newtomato.me/blog/2017/12/09/openglji-chu-ju-zhen-zhi-shi"/>
    <updated>2017-12-09T20:07:39+08:00</updated>
    <id>http://www.newtomato.me/blog/2017/12/09/openglji-chu-ju-zhen-zhi-shi</id>
    <content type="html"><![CDATA[<p>[TOC]</p>

<p>作为游戏开发者，我们将任何显示对象放到舞台上的时候，可能都没有想到在这后面有一套复杂又快速的东西保证了我们能够立马看到想要的效果。而这里背后的东西，我们称之为渲染引擎。</p>

<p><code>cocos2dx</code>使用便是<code>opengl</code>的图形编程接口。我们想要彻底搞懂cocos2dx，就需要了解opengl。而这里会介绍<code>opengl</code>矩阵和坐标的基础知识，最后搞明白上面提到的问题，一张图片是怎么渲染到舞台上的。</p>

<!--more-->

<h2 id="section">齐次坐标</h2>

<p>cocos2dx和opengl中，有大量的数学计算。例如比如位置的变化。通过代码我们知道，这些计算使用都是矩阵。<br />
这些矩阵有什么特别的？他们特别的在于都是4维矩阵。<br />
而cocos2dx最多是3维，opengl也是为3维设计的接口，为什么会有4维？</p>

<p>因为这样的坐标更容易进行矩阵乘法，他们被称之为齐次坐标。</p>

<blockquote>
  <p>在数学里，齐次坐标（homogeneous coordinates），或投影坐标（projective coordinates）是指一个用于投影几何里的坐标系统，如同用于欧氏几何里的笛卡儿坐标一般。该词由奥古斯特·费迪南德·莫比乌斯于1827年在其著作《Der barycentrische Calcul》一书内引入[1][2]。齐次坐标可让包括无穷远点的点坐标以有限坐标表示。使用齐次坐标的公式通常会比用笛卡儿坐标表示更为简单，且更为对称。齐次坐标有着广泛的应用，包括电脑图形及3D电脑视觉。使用齐次坐标可让电脑进行仿射变换，并通常，其投影变换能简单地使用矩阵来表示。<br />
如一个点的齐次坐标乘上一个非零标量，则所得之坐标会表示同一个点。因为齐次坐标也用来表示无穷远点，为此一扩展而需用来标示坐标之数值比投影空间之维度多一。例如，在齐次坐标里，需要两个值来表示在投影线上的一点，需要三个值来表示投影平面上的一点。</p>
</blockquote>

<p>上述介绍来源自维基百科对<strong>齐次坐标</strong>的介绍.<br />
注意，齐次坐标可以比笛卡尔坐标更为简单，且更为对称。事实上也的确如此。</p>

<h3 id="section-1">齐次坐标的特征</h3>

<p>我们举例说明什么是齐次坐标。一个二维坐标（x,y）,如果转为齐次坐标就是（kx,ky,k）。<br />
<code>规律就是他比原来坐标多一维。且有相同的系数。</code><br />
在这个规律下，(3,4)对应的齐次坐标可以是（3，4，1），（6，8，2），（9，12，3）等等。</p>

<h3 id="section-2">齐次坐标如何区分点和向量</h3>

<p>我们向量的表示和点的是一样的。（3，4）可以认为是一个点，也可以认为是从原点出发的一个指向(3,4)的向量。<br />
那么在齐次坐标中，是如何区分这两种不同的表示呢？<br />
向量的意义最重要的不是他的数值而是他的方向。而点没有方向，只有位置。所以上面提到的<code>k=0</code>，则表示此是向量坐标，而<code>k=1</code>表示这是一个点坐标.<br />
[3，4，0]是一个方向向量，而[3,4,1]则是一个位置。</p>

<h2 id="section-3">仿射变换</h2>
<p>向量或者点经过矩阵线性变化加平移之后，转换为另一个向量或者点。<br />
放射变化可以表示成为如下的公式：<br />
<img src="http://7xuepc.com1.z0.glb.clouddn.com/2017-12-09-115125390754949.jpg" alt="-w300" /></p>

<p>这个公式是通过矩阵的缩放旋转以及平移之后计算得到的。所以仿射变换是复合变换。是基本矩阵变换相乘得来的。<br />
因此我们先得知道基本的矩阵变换。</p>

<p><img src="http://7xuepc.com1.z0.glb.clouddn.com/2017-12-09-15128224606470.jpg" alt="" /></p>

<p>有了上述公式，我们可以基本写仿射变化的公式了。</p>

<p><code>P' = M(平移)*M(旋转) * M(缩放) * P</code></p>

<p><code>P</code>代表原先的坐标，经过缩放，旋转，平移之后转换成了新坐标<code>P'</code>。这里需要注意的一点是矩阵的乘法规则是从右到左，也就是对P坐标先做缩放，在做旋转，最后做平移。</p>

<p>根据矩阵的特性，我们可以知道矩阵平移其实可以做成矩阵相加。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">M0 = M1 + M2(M均是3维矩阵)</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>而其缩放和旋转都是矩阵相乘，做成4位齐次坐标最大的好处是将相加的矩阵也可以以相乘的方式来计算。统一的操作方法会带来很多便利。</p>

<p>上面的矩阵转换能够让我们在不同坐标系的点进行转换。举例说明，你在办公室的位置是相对办公室这个房间而言的。房间的原点假设在前台。此时你距离前台位置是（100，200，0）。0代表层级，都是同一层办公室，自然为0。此时如果要计算你在地球上的位置，怎么计算？<br />
自然已经知道地球原点在哪里，按照这个原点计算你的位置。</p>

<p>最简单的方法自然是直接计算，地球原点到你之间的物理距离。<br />
如此自然可以，可是不是最好的，也不是最快的。如果又求你在这个国家的位置，国家的原点在首都。再求你在这一条街的位置，再求你在这个地区的位置，这么多的需求，是不是觉得这个方法不是特别有效？</p>

<p>最有效的方法，就是使用仿射矩阵。</p>

<p>知道自己在办公室的位置，那么直接求办公室前台（办公室原点）对一楼门卫（大楼原点）之间的矩阵转换M1。套用公式就能知道自己在大楼里面的位置。然后在一条街的位置，那就求一楼门卫在这条街原点的矩阵转换M2。剩下的大家举一反三就知道了。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">P' = M(n)*M(n-1)*M(n-2)*...*M1*P</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>因此可以推论得知，空间坐标转换最重要的就是求解一个仿射矩阵。</p>

<p>在opengl的世界中，我们将要接触到很多空间转换的事情。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">本地屏幕坐标-&gt;世界坐标-&gt;观察坐标(摄像机坐标，eye坐标)-&gt;裁剪坐标-&gt;投影坐标-&gt;标准设备坐标-&gt;屏幕坐标
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p><img src="http://7xuepc.com1.z0.glb.clouddn.com/2017-12-09-115128146409840.png" alt="-w350" /><br />
因此在opengl中他的最终的参见坐标公式如下：</p>

<math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
  <msub>
    <mi>V</mi>
    <mrow class="MJX-TeXAtom-ORD">
      <mi>c</mi>
      <mi>l</mi>
      <mi>i</mi>
      <mi>p</mi>
    </mrow>
  </msub>
  <mo>=</mo>
  <msub>
    <mi>M</mi>
    <mrow class="MJX-TeXAtom-ORD">
      <mi>p</mi>
      <mi>r</mi>
      <mi>o</mi>
      <mi>j</mi>
      <mi>e</mi>
      <mi>c</mi>
      <mi>t</mi>
      <mi>i</mi>
      <mi>o</mi>
      <mi>n</mi>
    </mrow>
  </msub>
  <mo>&#x22C5;<!-- ⋅ --></mo>
  <msub>
    <mi>M</mi>
    <mrow class="MJX-TeXAtom-ORD">
      <mi>v</mi>
      <mi>i</mi>
      <mi>e</mi>
      <mi>w</mi>
    </mrow>
  </msub>
  <mo>&#x22C5;<!-- ⋅ --></mo>
  <msub>
    <mi>M</mi>
    <mrow class="MJX-TeXAtom-ORD">
      <mi>m</mi>
      <mi>o</mi>
      <mi>d</mi>
      <mi>e</mi>
      <mi>l</mi>
    </mrow>
  </msub>
  <mo>&#x22C5;<!-- ⋅ --></mo>
  <msub>
    <mi>V</mi>
    <mrow class="MJX-TeXAtom-ORD">
      <mi>l</mi>
      <mi>o</mi>
      <mi>c</mi>
      <mi>a</mi>
      <mi>l</mi>
    </mrow>
  </msub>
</math>

<h2 id="section-4">坐标</h2>

<p>坐标是相对了坐标系而言的，坐标系最重要就是定义了原点。<br />
对于游戏中的模型或者显示对象，他们都有自己的坐标系。比如我们物体A里面有一个子节点B在位置（100，100）处，那么这里的（100，100）就是相对于A的<strong>本地坐标</strong>计算的来。使用本地坐标是最直观的。<br />
在这个游戏世界中，还有一个<strong>世界坐标系，或者是View坐标系。也可以理解成舞台坐标系</strong>。舞台的物体很多，他们每一个都有相对于舞台原点的坐标。甚至嵌套的子节点也会拥有一个唯一的舞台坐标。计算方法，对应思考上面的仿射矩阵变换。<br />
假设舞台很大，玩家会通过拖拽的方式移动屏幕看到其他部分。<br />
舞台移动之后会影响opengl显示的图像。按照上面的公式，其实变化的只有<code>M(view)</code>。后面和前面的矩阵都没有变化，因此计算位置就会很快。<br />
而这里计算<code>M(view)</code>矩阵，通过摄像机来计算会更快。因为移动物体其实就是反向移动摄像机。</p>

<p>裁剪空间是对世界空间的的范围裁剪。只有在规定范围内的才会被显示出来。这种就是投影。有正交投影和透视投影。<br />
正交投影产生的效果就是前后一致的裁剪。主要用于2D游戏。<br />
<img src="http://7xuepc.com1.z0.glb.clouddn.com/2017-12-09-115128184208022.png" alt="-w250" />(正交投影)</p>

<p>透视投影会出现近大远小的效果。主要在3D游戏中使用。<br />
<img src="http://7xuepc.com1.z0.glb.clouddn.com/2017-12-09-115128184007944.png" alt="-w250" />(透视投影)</p>

<p><img src="http://7xuepc.com1.z0.glb.clouddn.com/2017-12-09-115128185556038.png" alt="-w250" />(图1)<br />
<img src="http://7xuepc.com1.z0.glb.clouddn.com/2017-12-09-115128157278548.jpg" alt="-w150" />(右手坐标系)</p>

<p>投影裁剪之后，只保留在视椎体内的坐标，然后将坐标转换为opengl要求的[-1，1]标准化设备坐标。<br />
最后<code>opengl</code>通过<code>glViewPort()</code>设定的屏幕分辨率将坐标有转换为屏幕坐标。</p>

<p>在这里使用opengl右手坐标系，因此上面(图1)中所示的坐标系就是opengl的坐标。在视椎体的正中心。因此x的坐标都会标准化成[-1,1]的范围。而y也同样如此。至于z，适用于深度测试来使用的，同一个z轴上的点，具体就是离near面近的点就可能直接使用，而其他的点可能被直接抛弃掉。</p>

<h2 id="section-5">接下来，扩展点什么</h2>

<p>这些矩阵变换和opengl坐标系的基础知识，能够更好的帮助我们理解接下来的矩阵推导。<br />
我们将要涉及的View矩阵(观察矩阵)和投影矩阵推导。<br />
而理解这两种矩阵推导又能帮助我们理解游戏引擎是如何将顶点数据传递给opengl，opengl又是如何处理这些顶点数据，展示到屏幕上来。</p>

<p>最后通过这些，我们会将cocos2dx的opengl渲染流程疏通一遍。更好去理解cocos2dx是如何运作的。</p>

<h2 id="section-6">参考链接</h2>

<ol>
  <li><a href="http://www.songho.ca/opengl/gl_projectionmatrix.html">OpenGL Projection Matrix</a></li>
  <li><a href="https://learnopengl-cn.readthedocs.io/zh/latest/01%20Getting%20started/08%20Coordinate%20Systems/">learnopengl-cn</a></li>
  <li><a href="https://oncemore2020.github.io/blog/homogeneous/">齐次坐标系入门级思考</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在xcode上运行OpenGL工程-使用Glitter]]></title>
    <link href="http://www.newtomato.me/blog/2017/12/03/opengl-glitter"/>
    <updated>2017-12-03T19:52:27+08:00</updated>
    <id>http://www.newtomato.me/blog/2017/12/03/opengl-glitter</id>
    <content type="html"><![CDATA[<p>鉴于我们一般都是在<code>https://learnopengl-cn.github.io</code>这里学习opengl。这个开源的工程的example是非常好的学习工程。但是在mac上运行起来还是很麻烦。上面提到了glew，glfw以及glad等还不足以运行这些工程，手动安装其他依赖也是很痛苦的过程。<br />
但是<code>glitter</code>帮助我们把这些依赖全部都管理起来了。</p>

<p>githud地址<a href="https://github.com/Polytonic/Glitter">在此</a>.</p>

<!--more-->

<p>git clone之后，在终端中输入：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class=""><span class="line">git clone --recursive https://github.com/Polytonic/Glitter
</span><span class="line">cd Glitter
</span><span class="line">mkdir Build
</span><span class="line">cd Build
</span><span class="line">cmake -G "Xcode" ..</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>就可以在Build中生成一个xcode工程。</p>

<p>这里我遇到最大的问题就是clone花费了很长时间，但是没有遇到安装失败的情况。<br />
但是这个工程只是一个壳，我们还需要把learnopengl的源码发进来。<br />
mac上使用的opengl版本过高以及一些屏幕分辨率的问题，我最终尝试到如下工程的修改刚好适合我的测试。作者对learnopengl的源码做了注释和部分修改。在他职业readme上说明了修改的地方：</p>

<p><code>https://github.com/THISISAGOODNAME/learnopengl-glitter</code></p>

<h2 id="learnopengl">如何运行learnopengl</h2>

<p>为了能够运行这些example工程，我们先创建一个<code>target</code>，例如<code>hello_window</code>，然后将hello_window里面的文件全部都拖放进来。<br />
此刻的target的hello_window需要配置很多才能运行，为了方便起见，我们直接复制<code>Glitter</code>出来一份，然后改名为hello_window。<br />
在<code>complie source</code>这里将hello window的文件全部包含进来。<br />
<img src="http://7xuepc.com1.z0.glb.clouddn.com/2017-12-03-15123014609016.jpg" alt="" /><br />
然后在scheme中选择hello_window，运行即可。</p>

<h2 id="section">需要注意的问题</h2>

<p>在mac创建一个矩阵对象，默认初始化似乎不正确。<br />
为了能够正确展示，凡是出现<code>glm::mat4 trans;</code>这样默认初始化的地方，请一律改为了<code>glm::mat4 trans = glm::mat4(1);</code>.</p>

<p>只有这样才能让矩阵转换生效。<br />
<img src="http://7xuepc.com1.z0.glb.clouddn.com/2017-12-03-Untitled.gif" alt="" /></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在xcode上运行OpenGL工程]]></title>
    <link href="http://www.newtomato.me/blog/2017/12/03/macshang-openglhuan-jing"/>
    <updated>2017-12-03T17:36:47+08:00</updated>
    <id>http://www.newtomato.me/blog/2017/12/03/macshang-openglhuan-jing</id>
    <content type="html"><![CDATA[<p>学习opengl最基础的方法就是将新手教程的工程先运行起来，实战才能收获经验。<br />
先介绍我的工作环境。<code>MAC Sierra 10.12.6</code>,<code>xcode 9.2</code>。</p>

<h2 id="section">手动安装依赖库，配置各种环境变量。</h2>

<h3 id="glfwglew">glfw以及glew安装</h3>

<p>自己安装各种依赖工具包，主要有<code>glfw</code>和<code>glew</code>,以及<code>glad</code>。</p>

<p><code>glfw</code>和<code>glew</code>最简单安装方法就是通过<code>brew</code>。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">brew install glfw
</span><span class="line">brew install glew</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>安装完成之后，会在被存放在<code>/usr/local/Cellar/glew/</code>以及<code>/usr/local/Cellar/glfw</code>这里。</p>

<!--more-->

<h3 id="glad">安装glad</h3>

<p>glad是非常重要的一个工具库，缺失这个库，即使你的工程能够编译通过，也运行不起来。因为opengl的接口函数是需要调用<code>gladLoadGL();</code>被加载进来。</p>

<p>安装的方法：<br />
	1. 到<a href="http://glad.dav1d.de/">http://glad.dav1d.de/</a>选择,3.3版本的opengl，Profile选择<code>Core</code><br />
	2. generate a loader。下载zip文件。<br />
	3. 解压缩之后，待会放到项目中。</p>

<h3 id="xcode">创建一个xcode工程开始配置</h3>

<ol>
  <li>
    <p>选择生成一个command line tool工程。</p>

    <p><img src="http://7xuepc.com1.z0.glb.clouddn.com/2017-12-03-15122917458581.jpg" alt="=w300" /></p>
  </li>
  <li>然后打开<code>Preference-&gt;Locations-&gt;Custom Pathes</code>,设置变量如下：<img src="http://7xuepc.com1.z0.glb.clouddn.com/2017-12-03-15122918927071.jpg" alt="" /></li>
  <li>
    <p>然后打开<code>Project</code>的基础配置，在<code>Header search paths</code> 和<code>Library search paths</code>这里设置</p>

    <p><img src="http://7xuepc.com1.z0.glb.clouddn.com/2017-12-03-15122921103307.jpg" alt="" /></p>
  </li>
  <li>
    <p>最后将上面的glad文件放入到项目中。</p>

    <p><img src="http://7xuepc.com1.z0.glb.clouddn.com/2017-12-03-15122933160778.jpg" alt="" /></p>
  </li>
  <li>最后配置要编译的库文件</li>
</ol>

<p><img src="http://7xuepc.com1.z0.glb.clouddn.com/2017-12-03-15122933998643.jpg" alt="" /><br />
6. 修改你的main.cpp文件。例如我这边使用<a href="https://pan.baidu.com/s/1bp548Bd">main.cpp 密码:yud8</a>在此。运行工程你应该可以看到一个三角形。</p>

<p><img src="http://7xuepc.com1.z0.glb.clouddn.com/2017-12-03-15122935323107.jpg" alt="=" /></p>

<p>至此第一种方法，配置mac上opengl的环境已经结束。虽然很费时间。但是这趟流程走下来确实也是值得的。<br />
下一遍文章我将介绍一个稍微简单的方法。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[安装pygraphviz遇到的问题]]></title>
    <link href="http://www.newtomato.me/blog/2017/11/21/pygraphviz"/>
    <updated>2017-11-21T16:50:21+08:00</updated>
    <id>http://www.newtomato.me/blog/2017/11/21/pygraphviz</id>
    <content type="html"><![CDATA[<h2 id="section">环境：</h2>

<pre><code>MacOS sierra
python 2.7
</code></pre>

<!--more-->

<h2 id="section-1">使用安装命令：</h2>

<p><code>	sudo pip install pygraphviz</code></p>

<p>命令行报错，不能正确安装。报错日志如下：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
</pre></td><td class="code"><pre><code class=""><span class="line">Collecting pygraphviz
</span><span class="line">  Downloading pygraphviz-1.3.1.zip (123kB)
</span><span class="line">    100% |████████████████████████████████| 133kB 1.5MB/s 
</span><span class="line">Installing collected packages: pygraphviz
</span><span class="line">  Running setup.py install for pygraphviz ... error
</span><span class="line">    Complete output from command /usr/bin/python -u -c "import setuptools, tokenize;__file__='/private/tmp/pip-build-qfFpFG/pygraphviz/setup.py';f=getattr(tokenize, 'open', open)(__file__);code=f.read().replace('\r\n', '\n');f.close();exec(compile(code, __file__, 'exec'))" install --record /tmp/pip-JmwjA6-record/install-record.txt --single-version-externally-managed --compile:
</span><span class="line">    running install
</span><span class="line">    Trying pkg-config
</span><span class="line">    Package libcgraph was not found in the pkg-config search path.
</span><span class="line">    Perhaps you should add the directory containing `libcgraph.pc'
</span><span class="line">    to the PKG_CONFIG_PATH environment variable
</span><span class="line">    No package 'libcgraph' found
</span><span class="line">    Traceback (most recent call last):
</span><span class="line">      File "&lt;string&gt;", line 1, in &lt;module&gt;
</span><span class="line">      File "/private/tmp/pip-build-qfFpFG/pygraphviz/setup.py", line 87, in &lt;module&gt;
</span><span class="line">        tests_require=['nose&gt;=0.10.1', 'doctest-ignore-unicode&gt;=0.1.0',],
</span><span class="line">      File "/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/distutils/core.py", line 151, in setup
</span><span class="line">        dist.run_commands()
</span><span class="line">      File "/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/distutils/dist.py", line 953, in run_commands
</span><span class="line">        self.run_command(cmd)
</span><span class="line">      File "/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/distutils/dist.py", line 972, in run_command
</span><span class="line">        cmd_obj.run()
</span><span class="line">      File "setup_commands.py", line 44, in modified_run
</span><span class="line">        self.include_path, self.library_path = get_graphviz_dirs()
</span><span class="line">      File "setup_extra.py", line 121, in get_graphviz_dirs
</span><span class="line">        include_dirs, library_dirs = _pkg_config()
</span><span class="line">      File "setup_extra.py", line 44, in _pkg_config
</span><span class="line">        output = S.check_output(['pkg-config', '--libs-only-L', 'libcgraph'])
</span><span class="line">      File "/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/subprocess.py", line 573, in check_output
</span><span class="line">        raise CalledProcessError(retcode, cmd, output=output)
</span><span class="line">    subprocess.CalledProcessError: Command '['pkg-config', '--libs-only-L', 'libcgraph']' returned non-zero exit status 1
</span><span class="line">
</span><span class="line">    ----------------------------------------
</span><span class="line">Command "/usr/bin/python -u -c "import setuptools, tokenize;__file__='/private/tmp/pip-build-qfFpFG/pygraphviz/setup.py';f=getattr(tokenize, 'open', open)(__file__);code=f.read().replace('\r\n', '\n');f.close();exec(compile(code, __file__, 'exec'))" install --record /tmp/pip-JmwjA6-record/install-record.txt --single-version-externally-managed --compile" failed with error code 1 in /private/tmp/pip-build-qfFpFG/pygraphviz/
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>看报错的消息应该是没有<code>pkg-config</code>这个命令，于是开始安装它。</p>

<p><code>brew install pkg-config</code></p>

<p>再次运行<code>pygraphviz</code> 安装命令，依然报错。</p>

<h2 id="section-2">最后的大招</h2>

<p>最后，经过各种google搜索和尝试，花费了我一上午的时间。才解决了这个问题。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class=""><span class="line">pkg-config --libs-only-L libcgraph
</span><span class="line">pkg-config --cflags-only-I libcgraph
</span><span class="line">pip install pygraphviz --install-option="--include-path='/usr/include/graphviz/'" --install-option="--library-path='/usr/lib/graphviz/'"
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>此时graphviz成功安装。在python中就可以使用了</p>

<p><code>import pygraphviz as gv</code></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ETC格式图片最佳实践]]></title>
    <link href="http://www.newtomato.me/blog/2017/11/12/etcge-shi-tu-pian-zui-jia-shi-jian"/>
    <updated>2017-11-12T15:04:27+08:00</updated>
    <id>http://www.newtomato.me/blog/2017/11/12/etcge-shi-tu-pian-zui-jia-shi-jian</id>
    <content type="html"><![CDATA[<p>最近整理android资源，发现有不少可以采用etc格式图片进行优化的地方。所以针对这块技术点进行了一下整理总结。分享给大家。</p>

<p><strong>etc是纹理压缩格式，可以不用cpu解压缩对齐像素而直接上传给GPU读取。GPU可以通过位置索引得到像素信息。也就意味着可以随机读取，快速准确。</strong></p>

<p>一张1024x1024的RGBA格式的图片，内存占用大约是1024x1024x4 = 4M。但是etc的每个像素占用0.5个字节。所以是0.5M。从这一点就有很多大的内存节约。</p>

<p>优点如上。</p>

<p>缺点就是不支持透明像素，而且图片的大小会变大很多。<br />
对于透明，我们可以采用shader的方式，对一张图片的像素处理让他能够呈现出透明。</p>

<p>具体的方案可以看<a href="http://malideveloper.arm.com/develop-for-mali/sample-code/etcv1-texture-compression-and-alpha-channels/">这里</a><br />
<!--more--></p>

<h2 id="section">开始</h2>

<p>我这里使用的是<code>MALI GPU</code> 厂商提供给开发者的工具<code>Mali GPU Texture Compression Tool </code>，可以将图片压缩成ect1或者etc2格式。</p>

<p><img src="http://7xuepc.com1.z0.glb.clouddn.com/2017-11-12-15104668339680.jpg" alt="" /></p>

<p>在导出的时候我们选择如何处理<code>alpha</code>。</p>

<p>第一种方式方式，放弃alpha通道数据。就是没有alpha也不影响图片显示。只有确定的不需要透明的图片可以才用这样的方式。比如模糊的大块儿图像。<br />
清晰的图像，掉透明会让纹理上出现波纹状的显示。肉眼容易看出来。</p>

<h2 id="section-1">图像和透明纹理合图</h2>

<p>第二种是创建透明和图片纹理的合图。上面是图像纹理，下面是透明纹理，通过shader读取上下对应纹理坐标的数据，相加得到真实的问题数据。<br />
这样的好处就是只要读取一个纹理采样即可。</p>

<p>VerticalShader修改为：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
</pre></td><td class="code"><pre><code class=""><span class="line">attribute vec4 a_v4Position;
</span><span class="line">attribute vec2 a_v2TexCoord;
</span><span class="line">varying vec2 v_v2TexCoord;
</span><span class="line">varying vec2 v_v2AlphaCoord;
</span><span class="line"> 
</span><span class="line">void main()
</span><span class="line">{
</span><span class="line">    v_v2TexCoord = a_v2TexCoord * vec2(1.0, 0.5);
</span><span class="line">    v_v2AlphaCoord = v_v2TexCoord + vec2(0.0, 0.5);
</span><span class="line">    gl_Position = a_v4Position;
</span><span class="line">}</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>FragmentShader修改为：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
</pre></td><td class="code"><pre><code class=""><span class="line">precision mediump float;
</span><span class="line">uniform sampler2D u_s2dTexture;
</span><span class="line">varying vec2 v_v2TexCoord;
</span><span class="line">varying vec2 v_v2AlphaCoord;
</span><span class="line">void main()
</span><span class="line">{
</span><span class="line">    vec4 v4Colour = texture2D(u_s2dTexture, v_v2TexCoord);
</span><span class="line">    v4Colour.a = texture2D(u_s2dTexture, v_v2AlphaCoord).r;
</span><span class="line">    gl_FragColor = v4Colour;
</span><span class="line">}</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>## 单独压缩的图像和透明纹理</p>

<p>第三种方式是对图像和透明单独生成两张纹理。当然也是用Shader来实现两个纹理“叠加”，缺点就是需要两个纹理的采样读取。</p>

<p>修改片段着色器</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class=""><span class="line">vec4 colour = texture2D(u_s2dTexture, v_v2TexCoord);
</span><span class="line">colour.a = texture2D(u_s2dAlpha, v_v2TexCoord).r;
</span><span class="line">gl_FragColor = colour;</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>至于最后一种方式，是第三种方式未压缩版本。暂时并未使用。所以在此不做叙述。</p>

<h2 id="section-2">结语</h2>

<p>在cocos2dx，我使用Sprite去使用这样的shader，都表现出我预期的样子。但是使用九宫格Scale9Sprite，则没有达到预期。Scale9Sprite从代码上看，已经对纹理做了切割。因此不满足上面Shader的纹理坐标系。导致读取不正确。</p>

<p>生成pkm图片的工具除了<code>Mali GPU Texture Compression Tool</code>，<code>texturepacker</code>也可以，早期的版本有些问题，但是现在的最新版已经支持导出Alpha通道的纹理图片了。<br />
<code>Mali GPU Texture Compression Tool</code>需要到mali开发者网站上下载，由于国内特殊情况，下载速度几乎回到10年前的速度。为此我放到百度云这里，需要的可以自取。</p>

<p>链接:http://pan.baidu.com/s/1pK8S1mF  密码:cab2</p>

]]></content>
  </entry>
  
</feed>
