---
layout: post
title: "破解apk文件"
date: 2015-12-27 11:25:19 +0800
comments: true
categories: 
---

此篇文章涉及到的工具
1. [apktool](http://www.softpedia.com/get/Programming/Debuggers-Decompilers-Dissasemblers/ApkTool.shtml#download)
2. [dex2jar](http://sourceforge.net/projects/dex2jar/)
3. [jd-GUI](http://jd.benow.ca/)

所谓道高一尺魔高一丈，做开发需要有职业道德，我们破解apk只是为了研究和学习而不是为了以此盗取别人的劳动成果用以牟利。
只有知道了apk是怎么被破解的才知道怎么最好防范。才知道我们自己做的加密是否有效。
<!--more-->
###查看APK里面的内容
上一篇文章我们提到了如何生成apk文件。但是apk文件里面包含了什么呢？如何查看？

首先，apk也即是一种压缩文件的格式。因此我们可以通过解压缩的方式讲文件先打开。（如果打不开，可以现将apk扩展名改为zip然后再解压缩）
打开之后，我们能够看到的文件内容如下：
![Alt text](./1450615912267.png)
AndroidManifest是看不到东西的，里面乱码一片。
assets是游戏里面的资源文件夹。c
lasses.dex则是源码压缩文件。同样也是无法打开。lib则是一些依赖的库。比如我们上一张提到的quickcocos2dx.so文件。
res则是Android工程需要用到的资源文件，比如闪屏图片。

因此单纯地通过解压缩是看不出的什么有用的东西的。AndroidManifest是一个工程的描述文件，怎么才能够看得到呢？

###解压缩APK
这个时候就用到了我上面提到的apktool文件！

```
apktool d xxxx.apk 
```
用这种方式就能够apk破解式的解压缩，直接就可以看到AndroidManifest文件里面的全部内容。
![Alt text](./38ccc90747d8eb7bb7863e12c397356d)

除了能够看到AndroidManifest文件，还可以看到源代码，但是这种方式查看源代码还是不够直观。因此打开之后看到的源码虽不是乱码但是不够直观。

那么还有什么办法呢？
当然有，还记得上面出现的class.dex文件么？我们可以用的dex2jar命令将这个dex转成jar包，然后使用jd-GUI的工具查看源码即可。
![Alt text](./a.jpeg)

这样一看，就能够看到我们的java代码并没有被加密。那么接下来就是要去加密！

###加密加密加密

重要的事情说三遍。

Android的加密一般使用ProGuard来进行混淆打包。在混淆过后，可以在工程目录的proguard中的mapping.txt看到混淆后的类名，方法名，变量名和混淆前的类名，方法名，变量名。
![Alt text](./1)

我们要做的就是在我们proj.android下面的proguard.txt文件里面定义我们自己的混淆规则。同时在project.properties里面写`proguard.config=proguard.txt`

混淆的文件的规则如下：

```
-include {filename}    从给定的文件中读取配置参数   
-basedirectory {directoryname}    指定基础目录为以后相对的档案名称   
-injars {class_path}    指定要处理的应用程序jar,war,ear和目录   
-outjars {class_path}    指定处理完后要输出的jar,war,ear和目录的名称   
-libraryjars {classpath}    指定要处理的应用程序jar,war,ear和目录所需要的程序库文件   
-dontskipnonpubliclibraryclasses    指定不去忽略非公共的库类。   
-dontskipnonpubliclibraryclassmembers    指定不去忽略包可见的库类的成员。  
  
保留选项   
-keep {Modifier} {class_specification}    保护指定的类文件和类的成员   
-keepclassmembers {modifier} {class_specification}    保护指定类的成员，如果此类受到保护他们会保护的更好  
-keepclasseswithmembers {class_specification}    保护指定的类和类的成员，但条件是所有指定的类和类成员是要存在。   
-keepnames {class_specification}    保护指定的类和类的成员的名称（如果他们不会压缩步骤中删除）   
-keepclassmembernames {class_specification}    保护指定的类的成员的名称（如果他们不会压缩步骤中删除）   
-keepclasseswithmembernames {class_specification}    保护指定的类和类的成员的名称，如果所有指定的类成员出席（在压缩步骤之后）   
-printseeds {filename}    列出类和类的成员-keep选项的清单，标准输出到给定的文件   
  
压缩   
-dontshrink    不压缩输入的类文件   
-printusage {filename}   
-whyareyoukeeping {class_specification}       
  
优化   
-dontoptimize    不优化输入的类文件   
-assumenosideeffects {class_specification}    优化时假设指定的方法，没有任何副作用   
-allowaccessmodification    优化时允许访问并修改有修饰符的类和类的成员   
  
混淆   
-dontobfuscate    不混淆输入的类文件   
-printmapping {filename}   
-applymapping {filename}    重用映射增加混淆   
-obfuscationdictionary {filename}    使用给定文件中的关键字作为要混淆方法的名称   
-overloadaggressively    混淆时应用侵入式重载   
-useuniqueclassmembernames    确定统一的混淆类的成员名称来增加混淆   
-flattenpackagehierarchy {package_name}    重新包装所有重命名的包并放在给定的单一包中   
-repackageclass {package_name}    重新包装所有重命名的类文件中放在给定的单一包中   
-dontusemixedcaseclassnames    混淆时不会产生形形色色的类名   
-keepattributes {attribute_name,...}    保护给定的可选属性，例如LineNumberTable, LocalVariableTable, SourceFile, Deprecated, Synthetic, Signature, and   
  
InnerClasses.   
-renamesourcefileattribute {string}    设置源文件中给定的字符串常量  
```


使用混淆经常会遇到以下的问题：
1. 混淆之后，类名和函数名发生变化，在lua中无法真确调用。
2. 第三方的类库不要去混淆，容易发生问题，导致无法正确调用，原因也是第一条引发的。

使用混淆之后，重新编译我们的项目，在用上面的方法破解，查看我们的代码，发现不少代码都混淆成了一些abc这样的名字。但是这样的混淆方法并不是唯一的。只是最常用的方法。






